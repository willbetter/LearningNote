Reference: [C、C++内存对齐详解](../resourse/htmls/C_C++内存对齐 _ 神奕的博客.htm)

# 什么是内存对齐

**内存对齐**也叫字节对齐。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任意类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排序，而不是一个接着一个的排放，这就是对齐。

# 为什么要进行内存对齐

之所以需要内存对齐，主要有两方面的原因：

* 平台原因：各个硬件平台对存储空间的处理上有很大不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。——比如，有些架构的CPU在访问没有进行对齐的变量时候会发生错误，那么这种架构下编程必须保证字节对齐。
* 性能原因：内存对齐可以提高存取效率。——比如有些平台每次都是从偶地址开始，如果int类型(假如32位)存放在偶地址开始的位置，那么一个周期就能读出来，如果存放在奇地址，则需要两个周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。

# 内存对齐的规则

每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。你可以通过预编译命令`#pragma pack(n)`，n=1,2,4,8,16 来改变这一系数，其中 n 就是你要指定的“对齐系数”。

**1）概念：**

**有效对齐值**：是 `#pragma pack`指定值 和 结构体中最长数据类型长度 中**较小**的那个。有效对齐值也叫**对齐单位**。

注意：VS、VC 默认是#pragma pack(8)，而 gcc 默认是#pragma pack(4)，并且gcc只支持1，2，4对齐。

**2）规则：**

1. 结构体变量的**首地址**是有效对齐值（对齐单位）的整数倍。
2. 结构体第一个成员的**偏移量（offset）**为0，以后每个成员相对于结构体首地址的 offset 都是**该成员大小与有效对齐值中较小那个**的整数倍，如有需要编译器会在成员之间加上填充字节。
3. **结构体的总大小**为 有效对齐值 的**整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。
4. 结构体内类型相同的连续元素将在连续的空间内，和数组一样。

# Objective-C中内存对齐规则