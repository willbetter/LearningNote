# 1. UI视图

UIView和CALayer有什么区别呢?

> CALayer是UIView用于绘制视图内容的部分，这样设计师符合类型单一职责原则的设计方案。CALayer主要用于绘制内容，就是屏幕上我们所看到的文字，图像，还有动画也是作用于Layer层级的。而UIView主要用于处理时间，设计到整个时间响应链条，查找事件发生的位置，判断响应事件的view，这些都是在UIView中进行判断处理的。
>
> UIView响应事件的能力来自于其继承自UIResponder，因此可以添加点击事件。
>
> NSView底层用于绘制部分也使用的CALayer。但是事件处理部分不同，因此Cocoa中主要处理的是鼠标事件，而CocoaTouch中主要处理的是触摸事件。



imageNamed和imageWithContainsOfFile两个方法的区别

> 1. imageNamed的方式加载图片，图片使用完毕会被缓存到内存中，内存消耗比较多，再次加载速度比较快。即使放到自动释放池中，这份缓存也不会被释放，如果图像较大或者较多，则这种方式会消耗很大的内存。适用于高频、图片小的资源。
> 2. imageWithContainsOfFile加载，图片并不会缓存，使用完毕会被释放，适用于使用频次低、图片比较大的资源。



比较frame, bounds有什么不同? 

> frame是指在该view在父view坐标系中的位置和大小。参照物是父view的坐标系统。
>
> bounds是指该view在本身坐标系统中的位置和大小。



遇到tableView卡顿吗? 会造成卡顿的原因有哪些?

> **1. 避免cell重新布局, 提前计算并缓存cell的树形和内容**
>
> cell的布局计算比较耗时, 最好是在创建cell之后就布局好, autolayout之类的东西, 之后如果能不改变其布局就不要去改变。如果cell是动态高度，如果每次cell重新进入屏幕都去计算，计算过程会浪费时间也会消耗不必要的cpu资源，这时候可以提前缓存cell的高度，需要的时候直接去取出来就行了。
>
> **2. 减少cell上控件数量， 尽可能不使用clearColor和透明度**
>
> 如果cell上控件数量多会导致渲染比较耗时，计算autolayout也会消耗更多的时间，一不小心就会导致卡顿。尽可能不要在cellForRow：方法中创建新的控件，控件尽可能在cell初始化时候创建完毕，之后拿来用就行了。另外尽可能不要使用clearColor，透明度的view需要将两个甚至多个图层颜色叠加计算最终的颜色，因此会消耗更多的cpu时间。
>
> **3.加载网络数据，下载图片都使用异步下载，尽可能缓存**
>
> 异步下载图片网络等数据，可重用的数据，尽可能缓存起来。
>
> **4.预渲染图像、预解码**
>
> 加载图片可以将图像放在子线程中进行预加载，在子线程中创建图片上下文，将图像绘制一遍，图像就会发生解码，这时候使用解码后的图像会更快一点。



描述你所了解的UIKit

![](../resourse/images/WX20190629-140837@2x.png)

> 所有能够看到的东西都继承自UIView，它主要来控制视图的显示，实现calayer相关的接口，比如绘制接口，它的子类有UIWindow、UILabel、UIImageView、UIWebView、UIScrollView等等等，其中有个子类是UIControl，其子类能够响应target-selector方式响应时间，有UIButton、UISwitch、UITextField等等。UIView的父类是UIResponder，只要是它的子类全部都能够响应事件，UIViewController、UIApplication、UITabbarController、UINavigationController都是它的子类。
>
> UIResponder同等级的类型有UIScreen、UIImage、UIDevice、UIColor、UIFont等对象。
>
> 然后可以阐述UIView和CALayer的关系。



高性能绘制图片圆角？

> 同时设置layer的maskToBounds和cornerRadius会触发离屏渲染。离屏渲染是GPU在当前屏幕缓冲区以外开辟新的缓冲区进行渲染的操作。如果一定使用触发离屏渲染的方式设置圆角，可以同时开启光栅化，开启光栅化可以使离屏渲染结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直使用离屏渲染损耗的性能。如果layer以及sublayer是经常改变，则会一直不停的 渲染以及删除缓存重新创建缓存，这种情况下不建议使用光栅化，因为在动态变化layer中使用光栅化会更加消耗性能。
>
> 另一个常用的设置圆角的方法是在图形上下文中自己绘制圆角图片，如果嫌绘制耗时，可以将绘制流程放在子线程中来完成，最后回调到主线程设置到imageView上。









#2. 内存管理

简单介绍内存分区？

> 我们的应用程序被加载到程序区. 应用程序被分为三部分加载到内存中, 代码段区（text）、已初始化数据区（data）、未初始化数据区（bss）。此区域之外是堆区（heap）和栈区（stack），堆区内存地址从低向高增长，栈区的内存地址从高向低增长。
>
> - stack：方法调用。
> - heap：通过alloc等分配的对象。
> - bss：未初始化的全局变量等。
> - data：已初始化的全局变量等。
> - text：程序代码。





# 3. Runtime

runtime高级面试题目

```objective-c
//MNPerson
@interface MNPerson : NSObject
@property (nonatomic, copy)NSString *name;
- (void)print;
@end

@implementation MNPerson
- (void)print{
    NSLog(@"self.name = %@",self.name);
}
@end
---------------------------------------------------
@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    id cls = [MNPerson class];
    void *obj = &cls;
    [(__bridge id)obj print];
}
```



这里为什么不会崩溃, 为什么打印了`self.name = <ViewController: 0x7fe667608ae0>` ? 

> 解答 [https://www.jianshu.com/p/117b5cb6a420](https://www.jianshu.com/p/117b5cb6a420)



Runtime如何通过selector找到对应的IMP地址？

> 详见InviewView Course中Objective-C消息转发流程。



为什么给nil发送消息不会崩溃？

> OC的函数调用都是通过objc_msgSend进行消息发送来实现的，相对于C和C++来说，对于空指针的操作会引起Crash的问题，而objc_msgSend会通过判断self来决定是否发送消息，如果self为nil，那么selector也会为空，直接返回，所以不会出现问题。视方法返回值，向nil发消息可能会返回nil(返回值为对象)、0（返回值为一些基础数据类型）或0X0（返回值为id）等。但是对`[NSNull null]`对象发送消息时，是会crash的，因为这个NSNull类只有一个null方法。
>
> 当然，如果一个对象已经被释放了（引用计数为0了），那么这个时候再去调用方法肯定是会Crash的，因为这个时候这个对象就是一个野指针（指向僵尸对象（对象的引用计数为0，指针指向的内存已经不可用）的指针）了，安全的做法是释放后将对象重新置为nil，使它成为一个空指针，大家可以在关闭ARC后手动release对象验证一下。



Swift支持KVO、KVC吗？

> swift是不支持kvo、kvc的，OC支持KVC的原因是NSObject遵循了`NSKeyValueCoding`协议，而OC中所有的类包括自定义类都继承自NSObject，所以都能够使用KVO、KVC。
>
> 要想在swift中使用KVC，我们就得将自定义的类继承NSObject，并且在声明变量前加上`@objc`。添加@objc的原因是KVO、KVC的实现原理是Runtime，而swift是一门静态语言，并没有Runtime这一说。
>
> 添加@objc后，这个属性或者方法都会使用OC Runtime那一套流程来进行处理。



# 4. Objective-C语言特性

重写一个类的方法，使用继承好还是使用分类号？为什么？

> 使用分类更好。使用类别仅会影响到本类，并不会影响到本类与其他类型的关系，符合软件设计的开闭原则。



@property的本质是什么? 

> @property = ivar + getter + setter
>
> 属性作为OC的一项特性，主要用于封装对象中的数据。oc对象通常会把所需要的数据保存为各种实例变量。实例变量一般通过存取方法来访问。
>
> 属性可以拥有的特质有：
>
> 原子性：atomic，nonatomic
>
> 读写权限：readwrite，readonly
>
> 内存管理语义：assign，strong，weak，copy，unsafe_unretained



weak和assign的区别

> weak和assign都不会触发引用计数，不同的是weak只能用来修饰oc对象类型，当其所指对象被释放之后，weak指针自动置nil；assign可以用来修饰oc对象也可以修饰基本数据类型，当其所致对象销毁后，指针会变成野指针，继续使用会导致程序崩溃。



我们说oc是动态运行时语言是什么意思？

> 就是说，oc中将数据类型的确定从编译时推迟到了运行时。简单说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。而像swift，java这样的语言，他们的类型是在编译时确定的，就是说，在编译时候就已经确定了方法调用，比如在某个位置调用了某个方法，编译后可能这里被替换成了一个函数指针，运行时执行到这里会直接进行方法的跳转。而oc中是在运行时通过isa指针找到方法列表依次遍历找到对应方法的。



delegate和Notification的区别？

> 代理主要用于一对一的消息通知功能，而通知主要是用于1对多的关系中。或者消息的发送者和接受者之间没有任何逻辑上关联，层级上没有联系但是又必须传递消息，这时候只能使用 通知了。



KVO实现原理是怎样的？

> KVO是观察者模式的一种实现，当被观察的属性发生更改时，观察者对象会获得通知。
>
> 在运行时，当一个对象第一次被添加了KVO监听之后，runtime会动态生成这个类型的一个子类，并动态将指向原始类型的isa指针指向其动态生成的子类。在子类中重写了对应属性的setter方法，当setter方法被触发的时候就会触发KVO通知，原理大概就是这样的。
>
> KVO是基于runtime机制实现的，KVO运用了isa-swizzling技术（isa混写技术），将两个对象的isa指针相互调换。

![](../resourse/images/WX20190629-173150@2x.png)



为什么不能直接通过`UIView.frame.origin.x = 10`来修改frame值？

> 因为通过UIView.frame获取到的属性会通过objc_msgSend方法进行方法调用，实际上是C语言级别的方法调用，C语言方法调用返回值是一个常量是不可被修改的，因此这样直接赋值会报错。frame结构体是值类型，通过这种方式获取到的常量是原有属性的一个拷贝，这个拷贝是一个常量，因此是不可被修改的。



iOS崩溃统计&收集原理？

> 首先，当应用崩溃时，会产生崩溃日志并且保存在设备上。崩溃信息描述了应用结束视乎所处的环境信息，通常包含完整的线程对战追溯信息，这些数据对于崩溃调试应用错误非常有帮助。包含追溯信息的崩溃日志在分析前需要进行符号化，符号化将内存地址替换为更加直观的函数名以及行为。
>
> 符号化：我们需要使用打包上传时候导出的dsym文件，将崩溃堆栈中的符号对应起来，相当于翻译一下，翻译成真实的函数名字，或者函数调用。
>
> 符号表：编译器将源码转换为机器码时，会生成一个调试符号表，表内是二进制结构到原始源码的映射关系。调试符号表保存在dSYM（debug symbol调试符号表）文件内。调试模式下符号表会保存在编译的二进制内，发布模式则将符号表保存在dSYM文件内用于减少包的体积。

# 5.Swift语言特性

比较Objective-C和Swift。

> OC最大的优点就是他的动态性，oc的运行时机制导致oc无所不能，我们可以再运行时任意的干预程序的执行，交换方法，交换isa指针，动态生成对象，动态生成类型，我们甚至可以通过js动态生成一个app。不好的地方就是没有命名空间，必须使用前缀来解决，oc语法和其它大众化的语言语法差异比较大；其次oc的动态性导致过于灵活，如果不注意代码规范，那么写出来的代码可以是灾难性的，发生bug找都不知道从哪找。
>
> Swift的话，我最喜欢的地方是它的可选类型，它从编译器的层面上禁止我们使用未解包的数据，虽然麻烦了点，但是保证了我们程序的安全，自从我使用swift搭建项目，项目的崩溃率真的会比使用oc降低很多很多。其次是它的协议类型，swift协议异常的强大，我们可以定义一个协议集成自另一个协议，也可以组合两个或者多个协议，这样实现接口隔离的设计原则，我们可以直接扩展协议实现协议方法，这样在遵守协议时候就不需要再实现，当然如果你遵守协议时候重新实现了协议方法，那么系统将会调用你新实现的协议方法。swift泛型可以让我们用一份代码干很多事情，泛型特化又保证了泛型的性能。Fundation中很多数据结构都使用struct实现，值类型能够保证安全性，在传递重新赋值时候都会发生复制，不会出现改了一个地方影响了其它地方这种bug。



swift和oc语言的本质区别是什么？

> 最本质的区别，swift是一门静态语言，类似java，c++一样，通过目击表来进行函数调用的。而oc是消息机制，所有的函数调用都是通过消息机制来进行调用的。swift中的函数，在编译器，如果能用静态派发系统就会尽可能的使用静态派发，这样能够很大程度的提升swift语言的运行速度，静态派发中系统可以使用内联来优化函数调用，换做是消息机制，这完全是不可能实现的。



swift中有runtime吗？

> swift语言本身是没有runtime的，它是一门静态的语言，它的方法调用都是通过查找目击表来实现的，类似C++的虚函数那样。但是swift的动态性是可以借助Objective-C来实现的，比如我们可以将一个属性或者方法前面加上`@objc`,`dynamic`,添加之后，我们在runtime中通过获取方法列表的方法就可以获取到这个方法，在调用的时候也会走oc消息发送机制来进行方法调用。

# 6. Block

简述对block和函数指针的理解?

> 相同点：他们都能实现回调的操作。
>
> 不同点：函数指针只能指向预先定义好的函数代码块，函数地址是在编译链接时就已经确定好的。Block本质上是一个OC对象，block不仅能够访问全局变量，还能访问局部变量。函数指针只是指向代码区的一段可执行代码，而block会在运行时栈上动态创建对象，发生copy操作能够将block转移到堆上。



block有哪些类型，为啥要用copy修饰？

> block的三种类型:
> 一 NSGlobalBlock：全局的静态block 没有访问外部变量 你的block类型就是这种类型（也就是说你的block没有调用其他外部变量）
> 二 NSStackBlock：保存在栈中的block，没有用copy去修饰并且访问了外部变量，你的block类型就是这种类型，会在函数调用结束被销毁 （需要在MRC）
> 三 NSMallocBlock 保存在堆中的block 此类型blcok是用copy修饰出来的block 它会随着对象的销毁而销毁，只要对象不销毁，我们就可以调用的到在堆中的block。
>
> 默认情况下，block会存档在栈中(栈是吃了吐)，所以block会在函数调用结束被销毁，在调用会报空指针异常，如果用copy修饰的话，可以使其保存在堆区(堆是吃了拉) ，它的生命周期会随着对象的销毁而结束的。只要对象不销毁，我们就可以调用在堆中的block。



# 7.多线程

比较NSOperationQueue和GCD。

> 使用NSOperationQueue主要可以用来管理子类化的NSOperation对象，控制器线程并发数目，取消已经添加到队列中的任务，但是这个取消并不是真正的将任务状态从执行变成取消，而是做一个标记，当任务执行任务执行完毕后，不去触发回调而已，正在执行的任务是没办法取消掉的。NSOperationQueue是面向对象变成的，在项目中会让项目结构更好。可以实现多个任务的依赖协调，更加精细化的控制线程的执行。
>
> GCD的话非常简单易用，简洁明了，可读性比较高，使用频次也是比较高的。通过dispatch_barrier也可以实现多个任务的依赖协调。
>
> GCD是镀层的C语言构成的API，NSOperationQueue是相关OC对象。NSOperationQueue是GCD基础上实现的，是GCD更高级的抽象。NSOperationQueue可以方便的建立任务的依赖关系；NSOperationQueue支持KVO监听operation是否在执行，是否被取消等。
>
> 从编程原则上，我个人比较习惯面向对象封装的NSOperationQueue，GCD会作为一个备选项，能不用就不用。



GCD的实现原理是怎么样的？

> GCD底层有一个线程池，这个池中存放的是一个个的线程。线程池中的线程是可重用的，当然会有确定的线程上限，上限的值应该与机器内核数量和内核类型相关，由系统决定。当需要新线程时候，就从线程池取一条，进行初始化配置工作，完事把任务扔到线程中一步一步来执行，执行完毕做清理工作然后归还给线程。





# 8. Runloop

### NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?

> NSTimer不准，NSTimer默认被添加在runloop、主线程中的，defaultMode，main主要负责主线程事件，比如UI操作，计算，主线程在这时候可能产生阻塞，导致NSTimer不准；主线程有两个mode，当切换到trackingMode时候，defaultMode中事件是不会被触发的，也导致不准。
>
> 针对NSTimer存在问题，我们可以使用`dispatch source`来创建更加精确的计时器，我觉得这个dispatch source可能是通过直接创建一个source然后添加到commonMode中来实现的；CADisplayLink也要比NSTimer经度更高，CADisplayLink会在每次屏幕刷新只有调用，而ios上屏幕刷新频率是固定的。
>
> **GCD做计时是准确的，GCD的线程管理是通过系统直接管理的，并不依赖主线程阻塞的影响**。GCD timer直接通过dispatch port给runloop发送消息，来使runloop执行相应的block，如果所在线程没有Runloop，那么GCD会临时创建线程去执行block，因此GCD的timer不依赖runloop。



runloop内部如何实现逻辑的？

> 详见InviewView Course中Runloop实现逻辑。



# 9. 网络

什么是Socket？



什么是心跳？



http集中请求方式？

> * GET:获取指定资源。
> * POST：向指定资源提交数据进行处理请求，在RESTFUL分各种用于新增资源。
> * HEAD：获取指定资源头部信息。
> * PUT：替换指定资源，不支持浏览器操作。
> * DELETE：删除指定资源。



http三次握手四次挥手？



https通信加密原理？



http和https的区别？





# 10. 软件架构

**一般开始做一个项目，你的架构是如何思考的？**

Reference: [iOS应用架构谈 view层的组织和调用方案](https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html),  [iOS应用架构谈 网络层设计方案](https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html)

上面两篇博客讲的不错，可以参考一下。



网络层设计方案

> 网络层最核心的问题:安全问题/速度问题/弱网络问题. 这块需要涉及的东西还是比较多的，如实回答，没有涉及到就好了。
>
> 可以参考:https://mp.weixin.qq.com/s/BIfya6eVaWZW9ZEVz8RRcg, 



你是如何进行组件化解耦的？

> 模块化设计，抽离基础组件，实现基础的功能。
>
> 抽离跨App的业务组件，此组件不依赖App，不可以在多个App中使用。定义统一的对外接口。
>
> 抽离App相关的业务组件，比如加油首页，个人中心，登录注册等功能模块。
>
> 业务模块之间通信的话，现在如果让我来设计这样的组件通信，我会用Target-Action的方法来实现，因为这样解耦更加的彻底。我们无需再App启动时候注册各个组件相关的功能。



MJRefresh实现原理是什么？

![](../resourse/images/687474703a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f67323031352f3439373237392f3230313530362f3133323233323435363133393137372e706e67.png)

> 上图来自于MJRefresh在[Github](https://github.com/CoderMJLee/MJRefresh)的图。从上图可以看出，整个刷新组件的实现是基于`MJRefreshComponent`的，然后`MJHeader`和`MJFooter`都继承自MJRefreshComponent，再往下就是Header和Footer根据不同状态自定义一些内容了。
>
> 整个框架中，MJRefreshComponent是一个抽象类。这个类型主要实现了view的初始化；KVO监听；定义公共方法等。KVO主要监听scrollView的contentOffset和contentSize和手势，当发生相关的事件都会触发特定的方法，但是这些方法的实现都是空的，都交给子类来实现了。**这部分是上下拉刷新实现的核心，其本质就是通过KVO监听scrollView的相关属性来进行不同调用来实现的。**
>
> 总的来说，上下拉刷新的原理就是先把刷新控件添加到scrollView的头部或者底部，然后通过KVO监听到scrollView的滚动进度（底部刷新还需要监听scrollView的内容的改变，每次改变后再次将控件调整到scrollView的底部），根据不同的进度来设置控件的相对应的文字和图片动画等。



SDWebImage原理

![](../resourse/images/1603505-22acf058b1e72e17.png)

> 1. 调用setImageWithURL:方法可以同时设置图片的占位图；然后通过SDWebImageManager类来启动图片的下载流程。
> 2. 如果图片在内存中已经缓存，则SDWebImageManager会调用SDImageCacheDelegate，直接在前端显示出来图片信息。
> 3. 如果内存中没有图片缓存，那么会生成`NSInvocationOperation`任务并添加到队列中，从硬盘上查找图片是否已经被下载缓存。
> 4. 根据URLKey在硬盘缓存目录下尝试读取图片文件，如果读取到了图片则会将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。然后回调并展示图片。
> 5. 如果硬盘上没有找到图片，则回调到未找到的代理方法中。
> 6. 这时候会使用共享的或者新生成的一个下载器开始`SDWebImageDownloader`开始下载图片。
> 7. 图片的解码处理在一个NSOperationQueue钟完成，所以并不会拖慢主线程UI，如果有对图片进行二次处理的需求，最好也在这里处理，效率会高一点。
> 8. 下载完成之后，首先回调展示图片。然后将图片保存的SDImageCache中，内存缓存和磁盘缓存同时进行保存。写文件到磁盘单独在NSInvocationOperation中完成，避免拖累主线程。
> 9. SDImageCache在初始化的时候会注册收到内存警告的通知，当收到警告的时候，会自动清理内存图片缓存。在应用结束的时候会清理过期的缓存图片。



JSPatch原理是什么？

> [JSPatch实现原理详解](https://github.com/bang590/JSPatch/wiki/JSPatch-实现原理详解)
>
> JSPatch能做到通过JS调用和改写OC方法最根本的原因是Objective-C是动态语言，OC上所有的方法的调用、类的生成都通过Runtime在运行时来进行，我们可以通过类名、方法名反射得到相应的类和方法。所以JSPatch的基本原理就是：**JS传递字符串给OC，OC通过Runtime接口调用和替换OC方法，这是最基础的原理，实际实现过程还有很多怪要打。**
>
> JSPatch大概的实现原理是这样的：
>
> 1.首先通过`require`方法指定一个类型，require方法会在全局作用于生成变量，这个变量实际上保存的是OC类名字。
>
> 2.在js中直接调用OC方法的实现逻辑：OC执行JS脚本前，通过正则把所有方法调用都改成调用`__c()`函数，再执行这个JS脚本。然后在这个方法中根据对象类型判断做不同的操作，这样避免在JS对象中保存这些方法，内存消耗直降99%。
>
> 3.JS和OC的消息传递用到了JavaScriptCore的接口，OC端在JSpatch引擎启动时候会创建一个`JSContext`，JSContext是js代码执行的环境，可以给JSContext添加方法，js就可以直接调用这个方法。JS 通过调用 `JSContext` 定义的方法把数据传给 OC，OC 通过返回值传会给 JS。



MVVM不使用框架该怎么实现绑定？

> 如果是在Objective-C中，可以通过KVO技术实现绑定，当然直接使用KVO还是比较麻烦的，一种比较好的做法是，我们需要对KVO进行一层封装，添加要监听的key，然后通过Block闭包来处理回调结果。
>
> 如果是在swift中，因为swift是不支持KVO的，所以没法用KVO。我们可以使用通知来实现属性变化的监听，在实际使用过程中，我们可能需要封装我们自己的通知中心，实现一个Obsesrvable协议，在协议中包装真实数据并提供便利的方法，以此来实现双向绑定。



# 11. 算法





# 其它

App冷启动和热启动的区别是什么？

> **app冷启动**： 当应用启动时，后台没有该应用的进程，这时系统会重新创建一个新的进程分配给该应用， 这个启动方式就叫做冷启动（后台不存在该应用进程）。
>
> **app热启动**： 当应用已经被打开， 但是被按下返回键、Home键等按键时回到桌面或者是其他程序的时候，再重新打开该app时， 这个方式叫做热启动（后台已经存在该应用进程）。



iOS编译过程做了那些事情?

> 编译型语言在执行时候，必须先通过编译器生成机器码，机器码可以直接在cpu上执行，所以执行效率比较高。
>
> 不管是swift还是oc都是使用LLVM作为编译器后端的，oc、c、c++使用clang作为编译器前段，swift使用swiftc作为编译器前段。编译器前段主要进行语法分析、语义分析，这时候如果发现代码错误或者警告编译器都会有提醒，最终生成LLVM支持的IR中间件。然后编译器后端会将IR统一的中间件代码进一步的优化，比如bitcode，然后会针对不同的cpu架构做不同的优化操作。
>
> swift的编译过程也差不多，不一样的地方在swift编译器前段，swift编译器前段也是进行语法分析，语义分析，然后他会生成swift专属的SIL中间件，在SIL基础上，编译器会针对语言进行大量的优化，swift性能之所以能够那么高也是因为这里进行了很多的优化。优化完事之后也会生成IR中间件，交给LLVM编译器进行进一步的优化，最后生成正对不同CPU架构的代码。



字典的实现原理是什么?

> 字典主要是通过hash算法来实现key-value之间的映射，以此来实现数据存储的。
>
> 哈希表本质应该是一个数组，value所在的index是通过hash算法计算出来的，如果发生了hash冲突，有两种解决方案，一种是开放寻址法一种是拉链法，拉链法就是后面拉一个链表，使用拉链法，当链表长度很长可以将链表转换成红黑树、跳表或者其它更加高效的数据结构，java中有个hashMap好像就是拉链，超过8个元素时候链表会转换成红黑树，红黑树支持更加高效的增删改查。
>
> hash算法中还有一个概念叫装填因子，在拉链法中可以保持装填因子大于1时候，效率也一样比较高，但是在开放寻址法中，必须保证装填因子小于0.8甚至更小，否则寻址会浪费很多时间。



OC中你了解的锁有哪些? 在此基础上二次提问:

追问一：自旋和互斥对比？ 

追问二：使用以上锁需要注意哪些？ 

追问三：用C/OC/C++，任选其一，实现自旋或互斥？口述即可！ 

> 在计算机科学中，锁是一种同步机制，用于在存在多线程的环境中实施对资源的访问限制，可以理解成用于排除并发的一种策略。
>
> 在ios中常见锁有递归锁、自旋锁、普通的锁。主要有以下几种：NSLock，@synchronize、NSRecursiveLock、OSSpinLock。
>
> 自旋锁和互斥锁的区别：互斥锁，如果共享数据已经被其它线程加锁，线程会进入休眠状态，等待被唤醒，被加锁的线程在解锁后会通知睡眠的线程唤醒，并继续执行任务。自旋锁，如果共享数据被其它线程加锁，线程会死循环的方式不停尝试是否解锁，一旦资源被解锁，等待线程会被立马执行。
>
> 自旋锁的效率高与互斥锁，但是循环等会会消耗额外的cpu资源。对于操作比较简单的加锁任务适合使用自旋锁，比如oc中引用计数的加减操作。
>
> 实现自旋锁或者互斥锁：从两种锁的实现原理入手，描述两种锁的实现。



内存泄露可能出现的几种原因是什么?

非OC对象内存泄露怎么处理? 地图的内存泄露怎么处理? 如果常用框架出现内存泄露怎么处理?

> 最主要的原因可能是循环引用。block属性中强持有的self，代理没有加weak，NSTimer循环引用，第三方库的内存泄漏等
>
> 对于程序中用到的非oc类型，需要手动执行内存释放操作，比如CG开头哪些绘制的类型。
>
> 地图类型是比较耗费内存的，这个需要详细阅读文档，正确的使用地图类型，使用完毕时候注意将地图的代理置空。大头针要注意复用，使用完毕后清理数组。



项目做容错处理了没有? 如果拦截潜在的崩溃?

> 团队开发中，水平参差不齐，很难控制代码质量，为了保证代码健壮性问题，需要做容错处理。
>
> 最近两年我用的swift开发，实际上，在swift开发中很少发生崩溃，因为swift引入可选类型，针对可选类型必须解包之后才能用，相当于在语言层面上，强制你必须去判断值是否是空。保证了程序的健壮性。针对项目中的swift代码，以及调用三方库或者系统的代码，我们从runtime上进行了拦截，在release环境中，对uncongnizeSelector进行拦截处理，不让程序崩溃。
>
> 在开发中不能过分相信服务端数据会永远正确；数据处理上，要进行容错处理，进行判断后再使用是好的编程习惯。



简述APNS消息发送机制

> 1. 在客户算，应用程序向iOS操作系统注册通知，然后iOS系统会给对应app生成全网唯一的一个device token。
> 2. 应用程序在接收到token之后，将token发送给自己的服务器。
> 3. 当需要发送推送通知时候，服务器把要推送的内容token以及发送给APNS服务器。
> 4. APNS服务器通过其与ios系统保持的长连接，找到对应的设备，将消息推送到对应的iOS设备上去。



http协议中，post和get有什么区别？

>  get一般用于向服务器请求数据，post用于提交数据; get请求参数是直接拼接在url上面，长度是有限的，不适合传输图片密码等； post没有长度的限制，其请求参数被放在body中。



有使用过runtime运行时吗？用它做了什么？

> 用过。
>
> 1. 用来交换两个方法的实现。主要用法是在load方法中，先获取方法的Method对象，然后通过`method_exchangeImplementations`交换两个方法的实现。
> 2. 很早之前使用oc时候，对象转模型的方法。通过runtime生成模型类型，获取类型方法列表属性列表，把字典中的值存放到对应的model中并返回出去。



自动释放池是什么？如何工作的？

> 自动释放池是以栈为结点的双向链表数据结构构成的。当创建一个自动释放池时候，实际上只是向自动释放池栈结构push一个占位的标记结点。之后如果遇到[obj release]，则会直接将obj push到栈结构的最上层。当执行自动释放池pop操作时候，会从自动释放池栈中取出元素并执行它们的release操作，销毁掉元素，自动释放池一直执行pop操作，直到遇到标记位停止。



dSYM你是如何分析的？

> 我们项目有将符号表上传Apple开发中账号后台，我们会在Xcode构建版本中去查看崩溃信息。另外我们项目集成了bugly，我们使用脚本在Archive时候会将dsym文件上传bugly服务器，我们也开会在bugly上查看崩溃或者卡顿信息，然后定位 问题解决问题。并没有直接对dsym文件进行过完整分析。



深入理解iOS App启动过程&优化启动时间

> App启动过程：
>
> 1. dyld加载Mach-O文件，加载动态库。dyld首先会读取Mach-O文件的Header和load commands，接着就知道这个可执行文件依赖的动态库。dyld通过递归加载的方式将所有依赖的动态库加载到内存中。其中大多说是系统的动态库。
> 2. Rebase和Bind。Rebase用来修正内部指向当前Mach-O文件的指针指向，因为Mach-O文件被加载到内存中后，会进行一个随机偏移，这是为了增加破解反编译的难度，偏移后Mach-O内部指向地址就不对了，所以这里也需要做一个偏移。Bind是将Mach-O调用系统动态库的地方函数进行绑定，因为系统动态库所在内存地址并不是固定的，我们需要通过在加载时候动态绑定到正确的地址上去。
> 3. Objective-C Runtime初始化。OC是被动态语言，在执行main函数之前，需要把类的信息注册到一个全局的Table中。同时，需要将Category中方法注册到对运营的类型中。
> 4. main函数之后，创建UIApplication，UIWindow，UIViewController。
>
> 优化启动时间：
>
> 我们所处的优化启动时间一般是指优化冷启动的启动时间。冷启动的启动过程分为main函数之前和main函数之后，实际上主要的性能问题一般存在在main函数之后，因此main函数之后的优化应该是优化的重点。
>
> 1. 调用`didFinishLaunchingWithOptions`方法。我们经常会在此方法中做一些初始化工作，我们可以将不必要的初始化工作放到异步线程中或者延迟执行。
> 2. 创建UIViewController，初始化UITableBarController。假如我们App存在多个TableBarItem，我们可以将第一个要显示 的创建出来，其它的先用同一个UIViewController代替，当用户点击时候再去创建真正的控制器。
> 3. 获取本地数据和网络数据。将数据获取放在异步线程中，添加加载等待的标识。



ios怎么防止反编译？

> 1. 本地存储数据解密，将数据加密后存储在本地（字符串，图片可以转换成Data类型然后计算反码或者异或运算）。
> 2. URL，关键的token，key等进行编码加密，防止被静态分析。
> 3. 代码混淆技术。混淆关键文件的方法名类名，变量名。



什么是事务？

> 事务是并发控制的基本单元。**所谓的事务就是一个操作序列，这些操作要么都执行，要么都不执行**，他是一个不可分割的工作单元。可以拿银行两个账号转账的操作来做比喻。
>
> 事务的基本特征：原子性、一致性、隔离性、持久性。



load和initinstance比较

> 系统都执行一次；假如父类和子类都被调用，父类在子类之前被调用。
>
> 1. load方法会在加载类的时候被调用，也就是ios启动的时候，就会加载所有的类，就会调用每个类的load方法。
> 2. initialize会在第一次使用这个类的时候被调用。在这里可以初始化静态变量等操作。
> 3. load会在main()之前被调用。initialize则在类实例化或类方法被调用时调用。
> 4. 将类型的初始化尽可能的写在initialize中更好，这里是懒调用的，如果你一直不适用这个类，则方法可能一直不会被调用，而load会在main之前被调用，增加应用启动时间。
> 5. 类在接受消息时，会先检查是否调用过initialize，如果没有则会先进行调用。initialize是通过`objc_msgSend`进行调用，并且Category中方法会覆盖类中的方法。



iOS沙盒目录结构

> 1. Documents:一般用来存放应用中建立的文件，如数据库文件，或程序中浏览到的文件数据。如果进行备份会将此文件夹中文件包括其中；
>
> 2. Library：
>    1. Preferences：存储应用的默认设置和状态信息；
>    2. Cache：用来存储缓存文件，此文件夹中数据在用用退出时不会删除。备份时不会备份此文件夹。文件需要手动的删除。
> 3. Tmp：存放即使创建的临时文件。在系统重启后会被清除。



NSURLConnection和NSURLSession有什么区别？

> 1. 关于文件下载。`NSURLConnection`在下载文件时候，会先将整个文件下载到内存中，再写入沙盒，如果文件比较大，就会出现暴涨的情况，并且没办法跟踪到下载的进度；而`NSURLSessionUploadTask`下载文件，会默认下载到沙盒中，不会出现内存暴涨的情况，但是下载完成后会将临时文件删除，需要自己在`completionHandler`回调中添加保存文件的代码。
> 2. 关于请求的控制。NSURLConnection实例化对象，实例化开始，默认就发送(同步)请求，不需要调用start方法，而cancel方法可以停止请求的发送，停止后不能继续访问，需要创建新的请求；NSURLSession有三个控制方法，取消、暂停、继续，暂停后的任务可以通过继续恢复当前的请求任务。
> 3. 关于配置信息。NSURLSession的构造方法`（sessionWithConfiguration:delegate:delegateQueue）`中有一个`NSURLSessionConfiguration`类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，资源管理，网络超时等。NSURLConnection依赖一个全局的配置对象，缺乏灵活性。



TableView滑动过程中不加载图片实现方案。

> 这个功能在iOS开发中算是比较常见的功能。具体实现就是，在滑动过程中`ccellForRow:`方法不去下载图片，在scrollView停止滑动的代理方法中加载当前屏幕正在显示的cell上的图片。



A/B测试是什么？

> AB测试是为Web或App界面或者流程制作一个或多个版本，在同一时间维度，分别让组成成分相同的访客群体（目标人群）随机的访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估出最好的版本，正式采用。
>
> AB测试用于验证用户体验、市场推广是否正确，而一般的工程测试主要用于验证软硬件是否符合设计预期，因此AB测试与一般的工程测试分属不同的领域。



什么是灰度发布？

> 灰度发布是指在黑白之间能够平滑过渡的一种发布方式。在其上可以进行AB测试，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有反对意见，那么逐步扩大范围，把所有用户都迁移到B上来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。
>
> **灰度期**：灰度发布开始到结束期间的一段时间，称为灰度期。
>
> **作用**：灰度发布是为了获得用户的意见反馈，完善产品功能，提升产品质量，让用户参与产品测试，加强与用户的互动，降低产品升级所影响的用户范围。
>
> **测试方法**：灰度发布与互联网公司常用A/B测试似乎比较类似，国外互联网公司似乎并没有所谓的灰度发布的概念。按照wikipedia中对A/B测试的定义，A/B测试又叫：A/B/N Testing、Multivariate Testing，因此本质上灰度测试可以算作A/B测试的一种特例。只不过为了术语上不至于等同搞混淆，谈谈自己理解的两者的差异。



Profile.lock文件有什么用途？

> Profile.lock文件最大的用处在于多人开发。对于没有在Profile中指定Pods依赖库版本的写法，`pod MJRefresh`, 当团队中某个人执行完pod install命令后，生成的Profile.lock文件就记录了当时最新Pods依赖库版本，这时团队中其他人check下来这份包含`.lock`文件的工程以后，再次执行pod install命令，获取下来的版本就和最开始用户获取到的版本一致。如果没有Profile.lock文件，后续所有用户执行pod install命令都会获取最新版本的依赖库，这就会造成同一个团队使用的依赖库不一致的问题，对团队协作开发来说是个灾难。
>
> 实际上在项目集成cocoapods时候，运行pod install后，项目根目录会生成**`Profile.lock`**, 而Pods目录中也会有**`Manifest.lock`**文件。Xcode编译项目的时候，会执行Build Phases中的`Check Pods Manifest.lock`脚本，这个脚本会校验Profile.lock和Manifest.lock，**如果两个文件不一致就会报错！**
>
> Manifest.lock是存放在Pods目录下的，这个目录一般不加入git版本控制；也是在pod install之后生成，是Podfile.lock的拷贝，**主要作用是为了校验已经安装的依赖库和Podfile.lock里的是否一致，保证大家使用相同的依赖版本**。



如何监控App卡顿？

> **通过监控Runloop状态来判断是否出现卡顿。**如果Runloop的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接接收下西欧系时间过长而无法进入下一步，就可以认为是线程被阻塞了，如果这个线程是主线程的话，表现出来的就是出现了卡顿。如果想要利用Runloop原理来监控卡顿，则需要关注这两个阶段。Runloop进入睡眠之前和唤醒后的两个loop状态定义的值，分别是`BeforeSource`和`AfterWaiting`。
>
> 监控原理：创建一个观察者，添加到主线程的common模式下，然后创建一个子线程持续监控主线程的状态。一旦发现在进入睡眠前的`BeforeSources`或者`AfterWaiting`，在设置的时间阈值内没有变化，即可判定是卡顿。接下来我们就可以dump出堆栈信息，从而做进一步分析出具体是哪个方法执行时间过长。
>
> 具体做法：添加一个Observer监听主线程Runloop所有的状态，当发现Runloop状态卡在某个状态下时间过长，则说明发生了卡顿，这时候dump出来方法调用堆栈信息并且保存即可，在何时的时间上传给服务器进行分析。



如何分析项目中某些方法是否被使用？

> [基于clang插件的一种iOS包大小瘦身方案.pdf](../resourse/material/基于clang插件的一种iOS包大小瘦身方案.pdf)
>
> 工具的话，使用AppCode可以进行分析。
>
> 分析原理的话，如上链接所示。首先代码之间存在调用关系。假设 iOS App的入口是`[UIApplication main]`，则所有开发者的源代码包括 第三方库都可以分为两类：存在一条调用路径，使得代码可以被主入口最终调用；不存在一条路径，使得代码最终不能被主入口调用。
>
> 代码编译过程，经过语法 分析后会生成语法树，我们可以编写Clang插件，检查这个语法树，检查是否存在调用路径的代码，然后剩下的方法就是没有被调用的代码，就可以删除掉。更加详细的插件编写过程可以参考如上链接所示。



swift如何阻塞一个线程？

```swift
//获取线程runloop
let ref = CFRunLoopGetCurrent()
//调用runloop阻塞
CFRunLoopRun()
//取消阻塞
CFRunLoopStop(ref)	
```



使用了哪些第三方库？有看他们是怎么实现的吗？

MJRefresh、Moya为例，谈到自己实现的CZBNetwork，封装的三方框架等。





# 面试题目归档

## 初级

1. 为什么说Objective-C是一门动态的语言？
2. 讲一下MVC和MVVM，MVP？
3. 为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别?
4. 属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？
5. 属性的默认关键字是什么？
6. NSString为什么要用copy关键字，如果用strong会有什么问题？（注意：这里没有说用strong就一定不行。使用copy和strong是看情况而定的）
7. nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？
8. 用StoryBoard开发界面有什么弊端？如何避免？
9. 进程和线程的区别？同步异步的区别？并行和并发的区别？
10. 如何使用队列来避免资源抢夺？
11. NSCache优于NSDictionary的几点？
12. 知不知道Designated Initializer？使用它的时候有什么需要注意的问题？

## 中级

#### **Block**

1. block的实质是什么？一共有几种block？都是什么情况下生成的？

#### **Runtime**

1. objc在向一个对象发送消息时，发生了什么？
2. 什么时候会报unrecognized selector错误？iOS有哪些机制来避免走到这一步？
3. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？
4. runtime如何实现weak变量的自动置nil？
5. 给类添加一个属性后，在类结构体里哪些元素会发生变化？

#### **RunLoop**

1. runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？
2. runloop的mode是用来做什么的？有几种mode？
3. 为什么把NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环以后，滑动scrollview的时候NSTimer却不动了？
4. 苹果是如何实现Autorelease Pool的？

#### **类结构**

1. isa指针？（对象的isa，类对象的isa，元类的isa都要说）
2. 类方法和实例方法有什么区别？
3. 介绍一下分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法？
4. 运行时能增加成员变量么？能增加属性么？如果能，如何增加？如果不能，为什么？
5. objc中向一个nil对象发送消息将会发生什么？（返回值是对象，是标量，结构体）

## **高级**

1. UITableview的优化方法（缓存高度，异步绘制，减少层级，hide，避免离屏渲染）
2. 有没有用过运行时，用它都能做什么？（交换方法，创建类，给新创建的类增加方法，改变isa指针）
3. 看过哪些第三方框架的源码？都是如何实现的？（如果没有，问一下多图下载的设计）
4. KVO的使用？实现原理？（为什么要创建子类来实现）
5. KVC的使用？实现原理？（KVC拿到key以后，是如何赋值的？知不知道集合操作符，能不能访问私有属性，能不能直接访问_ivar）

## 项目

1. 有已经上线的项目么？
2. 项目里哪个部分是你完成的？（找一个亮点问一下如何实现的）
3. 开发过程中遇到过什么困难，是如何解决的？

## 学习

1. 遇到一个问题完全不能理解的时候，是如何帮助自己理解的？举个例子？
2. 有看书的习惯么？最近看的一本是什么书？有什么心得？

### 其它

boss、作业帮、陌陌、美图

分类的底层实现;
自动释放池的底层实现, 主线程下, 对象的释放时机;
block的底层实现;
分类为啥不能添加成员变量, 只能添加方法;
还有给一个类添加分类后，不导入头文件，能调用分类方法吗;
消息机制里面，分类复写本类里面的方法后，为啥优先调用分类的方法而不是本类;
性能优化应该从哪几个方面着手;
block有哪些类型，为啥要用copy修饰;
声明属性的时候，有哪些默认修饰词;
常用设计模式有哪些，设计一个类的时候要遵循哪些原则（7大原则）;
KVO的原理底层实现;
再底层就问 LVVM的流程;
对clang有没有了解;
Masonry 是如何实现链式编程的;
关联对象里面的修饰词，为啥没有weak;
weak和assgin的区别   assgin能否修饰对象;
可变数组线程安全吗？如果不安全 设计一个可变数组（字典）来实现线程安全;
当有UITableView滑动的时候，NSTimer会停止工作，为什么;
如何去降低程序的耗电量;
简单说一下你这个项目的一个架构;
对MVP MVC MVVM的区别;
Block的本质是啥，回答代码块的话直接就pass了;
说一下消息机制以及消息转发;
个别公司会问七层网络模型是啥？HTTP工作在哪个层  TCP在哪个层;
如果让你来设计一个字典，你会如何实现？（变相问字典的底层实现原理）;
数据结构 一般都是问冒泡和快速排序， 偶尔问二叉树;



如果遇到自己不会或者不太懂的问题。

> 这个问题呢我没有深入的去了解，我只能说一下我的观点，然后把你掌握的相关的知识说一遍，然后推出一个可能的结果。