# 1.泛型

## 自由函数重载

swift有一套复杂的规则来确定到底使用了哪个重载函数，这套规则基于是否使用了泛型以及传入参数类型来确定。总的来说可以总结为一句话：**选择最具体的一个。**非通用的函数总是会优于通用的函数被调用。**重载的使用时编译器来决定的，就是说在编译器就已经确定好的。**

## 泛型工作原理

swift为泛型引入中间层。当编译器遇到一个泛型类型的值，将它包装到一个容器中。这个容器固定大小，并且存储这个泛型值。如果数据大小超过这个容器大小则在堆上申请内存，并将指针存储在容器内。

编译器对每个泛型类型参数维护一个或者一系列的目击表。其中包含值目击表以及泛型约束的每个协议目击表。在运行时，通过这些目击表将函数调用派发到正确的函数上去。

## 泛型特化

**泛型特化：**编译器按照具体参数类型，生成针对具体类型的函数，转换后的函数可以针对具体类型进行优化，移除泛型导致的额外开销，提升代码执行速度。这也让内联成为可能。

## 全模块优化

泛型特化只能在编译器可以看到泛型类型的全部定义以及想要进行特化的类型时才能生效。但是swift比那一起默认对源文件单独编译的。就是说只有使用泛型代码和定义泛型代码在同一个文件，泛型特化才能生效。

为了避免这种尴尬，引入了全模块优化。全模块优化会将整个模块中定义的泛型函数和使用看成整体来进行泛型特化的优化。同时优化器会识别出没有子类的internal类型，将这些类型的函数派发从动态派发转换成静态派发，进一步提升代码效率。

**泛型特化不能跨模块使用，标准库除外。**

## 其它

swift支持函数式编程，将方法（闭包）作为参数在方法中传递。**将行为参数化。**

通过泛型，提取共通功能，使用泛型表示。

# 2.协议

结构体、枚举也可以遵守协议。

使用协议好处是实现最小的实现接口。

1. 协议允许动态派发：定义在协议内部的方法会动态派发，定义在协议扩展中的方法会通过静态派发调用。

2. 带有关联类型和Self的协议，我们不能将它当成独立的类型使用，只能将它们用作类型约束。

## 类型擦除

针对上面2所存在的限制，我们可以通过类型擦除的方案来解决。具体原理是，创建真实的类型实现协议，协议中使用泛型参数进行实现，在具体的方法中将泛型参数转发出去。 需要使用协议定义的地方，通过真实类型+泛型参数来进行约束，完美！

## 协议原理

通过协议创建的变量，变量会被包装在不透明的存在容器中，不透明容器会占用比较大的空间，其中包括存储值的缓冲区、元数据、目击表（0个或者多个指针，指向不同协议的目击表）。不透明容器大小取决于目击表个数是多找，每个协议会对应一个目击表。

如果想要获得最大化的性能，使用泛型参数比协议类型高效的多，通过泛型参数可以避免隐士的泛型封装。

# 可选值

解包方法：if let、guard let、while let、if case、for case、while case、switch case、??。

在必须的时候是需要强解包的，通过可控崩溃保证程序的正确性。

# 结构体与类

结构体是值类型而类是引用类型，两者内存管理方式不同，类可以通过继承共享代码。

编译器会对结构体进行优化。使用传递引用而非值的方式来优化结构体常量。编译器会自动移除不必要的值类型复制。对于序列类型编译器会进行写时复制技术进行优化。编译器大部分时候会将结构体放在栈上而不是堆上，从而加快速度。

要想在值类型方法中直接修改自身的值，则需要在方法前面添加`mutating`。

Array、Dict、Set等类型，编译器会使用写时复制技术进行优化。

在Array中通过下表访问元素属性，并不会发生复制，因为Array返回的是地址器。标准库中其它类型Dict、set通过下标访问到的是元素的一个拷贝。

## 闭包与可变性

在swift中，函数是引用类型，如果函数闭合了一个变量，则函数作为参数传递之后，其引用计数会增加，其闭合的变量还是原来的变量。

swift结构体被存储在栈上而不是堆上，这是一种优化。默认结构体是存储在堆上的，但是大多数情况下其会被存储在栈上。1.结构体被函数闭合时候，优化不生效，其将被存储在堆上。2.如果结构体太大也会被存储在堆上。

函数参数添加inout标记，可在函数内部改变参数内容，改变后结果会被带出来。实现原理是，在函数执行结束后将结果复制回去。

# 函数

**头等函数：**指在程序设计语言中，函数被当成头等公民。意味着喊出可以作为别的函数的参数、函数的返回值、复制给变量或者存储在数据结构中。

函数能够捕获位于其作用域外的变量。被闭包闭合的变量将被存储在堆上。

在编程术语中，一个函数和它所捕获的变量环境组合起来被称为闭包。swift中，函数和闭包是完全等同的。

swift中可以重写云算法，定义自己的云算法，但是要慎用。切忌杀鸡用牛刀，除非你在写高度专用的事情，否则不要随便定义运算符。

## inout

**inout所做的事情并不是传递引用**，而是通过值传递，然后复制回来。

> 《Swift编程语言》：inout参数将一个值传递给函数，函数可以改变这个值，然后将原来的值替换，并从函数中传出。

在swift5中测试发现，inout标记参数，传递的是指针！！！

## @autoclosure

创建自动闭包，闭包参数可以是一个表达式，如果参数被标记@autoclosure，那么只有参数被使用时候才回去执行闭包获取返回值。

## @escaping

一个被保存在某个地方待稍后再调用的闭包被 **逃逸闭包**， 逃逸闭包需要使用@escaping标记。

**逃逸闭包的两种情况：**

1. 闭包在方法中被方法之外的属性存储。
2. 闭包被包装在多元组或者可选值中，闭包也必须是逃逸的。就是说，可选参数的闭包必须是逃逸的。

非逃逸闭包可以被编译器高度优化，快速执行。

**避免逃逸闭包方法：**

1. 给闭包设置默认值；
2. 重载函数，提供可选版本和非可选版本；

标记逃逸闭包后，会增加闭包的引用计数值。同时将失去被编译器高度优化的权利。

# Swift-Evolution

1. 添加浮点数判等函数，重新修订。
2. sequeue 添加`count(where:() -> Bool)`, 接受。
3. `toggle()`, swift5中已经被实现。

# Swift 5

