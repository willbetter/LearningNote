目录
=================

* [1.了解Objective-C的起源](#1了解objective-c的起源)
* [2.在类型的头文件中应该尽量少的引入其它头文件](#2在类型的头文件中应该尽量少的引入其它头文件)
* [3.多用字面量,少用与之等价的方法](#3多用字面量少用与之等价的方法)
* [4.对用类型常量,少用#define预处理指令](#4对用类型常量少用define预处理指令)
* [5.用枚举表示状态, 选项, 状态码](#5用枚举表示状态-选项-状态码)
* [6.理解"属性"这个概念](#6理解属性这个概念)
* [7.在对象内部尽量直接访问实例变量](#7在对象内部尽量直接访问实例变量)
* [8. 对象等同性](#8-对象等同性)
* [9. 使用类簇隐藏实现细节](#9-使用类簇隐藏实现细节)
* [10.在既有类中使用关联对象存放自定义数据](#10在既有类中使用关联对象存放自定义数据)
* [11. 理解objc_msgSend的作用](#11-理解objc_msgsend的作用)
* [12. 理解消息转发机制](#12-理解消息转发机制)
* [13. 用方法调配技术调试黑盒方法](#13-用方法调配技术调试黑盒方法)
* [14. 理解类对象的用意](#14-理解类对象的用意)
* [15. 使用前缀避免命名空间冲突](#15-使用前缀避免命名空间冲突)
* [16. 提供全能初始化方法](#16-提供全能初始化方法)
* [17.使用description方法](#17使用description方法)
* [18. 尽量使用不可变的对象](#18-尽量使用不可变的对象)
* [19. 使用清晰协调的命名方式](#19-使用清晰协调的命名方式)
* [20. 为私有方法名添加前缀](#20-为私有方法名添加前缀)
* [21. 理解Objective-C错误类型](#21-理解objective-c错误类型)
* [22. 理解NSCopying协议](#22-理解nscopying协议)
* [23. 通过委托与数据源协议进行对象间通信](#23-通过委托与数据源协议进行对象间通信)
* [24. 将类的实现代码分散于管理的数个分类中](#24-将类的实现代码分散于管理的数个分类中)
* [25. 总是为第三方类的分类名称加前缀](#25-总是为第三方类的分类名称加前缀)
* [26. 勿在分类中声明属性](#26-勿在分类中声明属性)
* [27. 使用class-continution分类隐藏实现细节](#27-使用class-continution分类隐藏实现细节)
* [28. 通过协议提供匿名对象](#28-通过协议提供匿名对象)
* [29. 理解引用计数](#29-理解引用计数)
* [30. 以ARC简化引用计数](#30-以arc简化引用计数)
* [31. 在delloc中只释放应用并解除监听](#31-在delloc中只释放应用并解除监听)
* [32. 编写异常安全代码留意内存管理问题](#32-编写异常安全代码留意内存管理问题)
* [33. 以弱引用避免保留环](#33-以弱引用避免保留环)
* [34. 使用自动释放池降低内存峰值](#34-使用自动释放池降低内存峰值)
* [35. 使用僵尸对象调试内存管理问题](#35-使用僵尸对象调试内存管理问题)
* [36. 不用使用retainCount](#36-不用使用retaincount)
* [37. 理解'块'的概念](#37-理解块的概念)
* [38. 为常见的块类型创建typedef](#38-为常见的块类型创建typedef)
* [40. 用块引用其所属对象不要出现保留环](#40-用块引用其所属对象不要出现保留环)
* [41. 多用派发队列,少用同步锁](#41-多用派发队列少用同步锁)
* [42. 多用GCD少用preformSelector系列方法](#42-多用gcd少用preformselector系列方法)
* [43. 掌握GCD以及操作队列的使用时机](#43-掌握gcd以及操作队列的使用时机)
* [45. 使用dispatch_once](#45-使用dispatch_once)
* [46. 不要使用dispatch_get_current_queue](#46-不要使用dispatch_get_current_queue)
* [47. 熟悉系统框架](#47-熟悉系统框架)
* [48. 多用块枚举,少用for循环](#48-多用块枚举少用for循环)
* [49. 对自定义其内存管理语义的collection使用无缝桥接](#49-对自定义其内存管理语义的collection使用无缝桥接)
* [50. 构建缓存使用NSCache而不是NSDictionary](#50-构建缓存使用nscache而不是nsdictionary)
* [51. 精简initialize与load代码](#51-精简initialize与load代码)
* [52.NSTimer循环应用问题](#52nstimer循环应用问题)

## 1.了解Objective-C的起源
oc使用消息结构而非函数调用. 区别在于: 使用消息结构的语言其函数调用是由运行环境来决定的, 使用函数调用的语言其运行时由编译器决定. 
Objective-C为C语言添加了面向对象的特性,是它的超集. oc使用动态绑定的消息结构, 也就是说, 在运行时才会检查对象类型. 接收一条消息之后, 酒精应该执行何种代码, 是由运行期环境而非编译器决定的.

## 2.在类型的头文件中应该尽量少的引入其它头文件
除非确有必要, 否则不要引入头文件. 一般来说, 应该在某个类型的头文件中使用`向前声明`来提及别的类型, 并在实现文件中引入那些类的头文件. 这样做可以尽量降低类型之间的耦合. 
有时候无法使用向前声明, 比如要声明某个类型遵守一个协议. 应该将协议写到一个分类中, 或者写到单独的头文件中. 

如果在一个类型的头文件中引入大量其它的头文件, 则别的类型引入此头文件也会引入大量的头文件. 这样会增加编译时间!

## 3.多用字面量,少用与之等价的方法
应该尽可能的使用字面量语法来创建字符串, 数值, 数组, 字典. 与创建此类对象的常规方法相比, 这么做更加的简明扼要. 
应该通过取下标的操作来访问数组下标或字典中的键对应的元素.
用字面量语法创建数组或者字典时候, 如果其中有nil则会导致抛出异常, 因此务必保证值里不包含nil.

## 4.对用类型常量,少用#define预处理指令
不要用预处理指令定义常量. 这样定义出来的常量不包含类型信息, 编译器只是会在编译前据此执行查找替换操作. 即使有人重新定义了常量值, 编译器也不会产生任何警告信息. 这将会导致程序中的常量值和定义的常量值不一致.
在实现文件中使用`const static`来定义`只在编译单元内可见的常量`. 由于此常量不在全局符号表中, 所以无序加前缀.
在头文件中使用`extern`	来声明全局常量, 并在相关文件中定义其值. 这种常量要出现在全局符号表中, 所以其名称前应该使用前缀加以区别, 通常用与之相关的类型做前缀.

## 5.用枚举表示状态, 选项, 状态码

## 6.理解"属性"这个概念
属性(@property属性)可以用来封装对象中的数据. 我们在类型中声明的属性,编译器在编译期会自动为我们生成get,set方法,还会为我们生成带下划线的变量,这一切都是在编译期间执行的. 我们也可以指定生成变量的名称(例如:`@synthesize firstname = _myFirstName`), 禁止编译器生成get/set方法(`@dynamic firstname`), 重命名get/set方法等. 

属性的特质: 原子性/非原子性, 读/写权限, 内存管理语义, 方法名(重命名getter/setter方法名字). **注意:** 一般我们将属性声明为非原子性操作,因为在ios中原子操作开销比较大; 如果将属性声明成只读的权限,则编译器不会生成setter方法; 

## 7.在对象内部尽量直接访问实例变量
在对象内部访问属性时候,一般情况下,在写入实例变量时候通过"设置方法"来做,在读取实例变量时候直接访问实例变量. 直接访问实例变来给你和调用设置/读取方法的区别:

1. 直接访问不会经过"方法派发"步骤,直接访问实例变量的速度更快;
2. 直接访问属性会绕过属性定义的内存管理语义,比如copy正常赋值使用直接访问方法,会直接释放旧值,持有新值,避免copy,更快;
3. 直接访问属性不会触发键值观察;

结论:

1. 在对象内部读取数据,应该直接通过实例变量,写入数据使用set方法;
2. 在初始化方法和delloc方法中,总是应该直接通过实例变量来读写数据;
3. 需要用到懒加载时候要使用属性访问数据;

## 8. 对象等同性
1. 若想要检测对象的等同性, 请提供isEqual:与hash方法;
2. 相同的对象必须有相同的hash码, 相同hash码的对象不一定是相同的对象;
3. 不要盲目的逐个检测每条属性, 而是应该依照具体需求来制定检测方案;
4. 编写hash时候, 应该使用计算速度快而且hash碰撞几率低的算法;

NSArray的等同性判定方法: 首先判断数组count个数是否相同; 然后分别对每个元素调用isEqual方法进行比较.

## 9. 使用类簇隐藏实现细节
1. 类簇模式可以把实现细节隐藏在一套简单的公共接口后面;
2. iOS Cocoa/CocoaTouch框架中经常使用类簇;
3. 从类簇的公共抽象基类中继承子类要当心, 若有开发文档, 则应该首先阅读;

## 10.在既有类中使用关联对象存放自定义数据
1. 定义关联对象时候可指定内存管理语义, 用以模仿定义属性时所采用的`拥有关系`和`非拥有关系`.
2. 只有在其它方法不可行的情况下才应该选用关联对象, 因为这种做法通常会引入难遇查找的bug.

在设置关联对象时, 若想要两个键匹配到同一个值, 则两者必须是完全相同的指针才行. 因此在设置关联对象时候, 通常使用静态全局变量做键. 如下代码输出是nil:

```
func setProperty(obj: NSObject, key: String, value: Any?, policy: objc_AssociationPolicy) {
    objc_setAssociatedObject(obj, key, value, policy)
}

func getProperty(obj: NSObject, key: String) -> Any? {
    return objc_getAssociatedObject(obj, key)
}

let vc = UIViewController()
setProperty(obj: vc, key: "viewcontrollerkey", value: "1111111", policy: .OBJC_ASSOCIATION_COPY)
let key = NSMutableString(string: "viewcontrollerkey") as String
let value = getProperty(obj: vc, key: key)

print(value)
```

**关联对象原理:** 查看源码会发现,`objc_setAssociatedObject`调用了`_object_set_associative_reference`方法, 其中会使用`AssociationsHashMap`来存储所有的associateObject类型.

## 11. 理解objc_msgSend的作用
1. 消息由接收着者, 选择子及参数构成. 给某消息`发送消息`也就相当于在该对象上`调用方法`.
2. 发给某对象的全部消息都要由`动态消息派发系统`来处理, 该系统会查出对应的方法, 并执行其代码.

`objc_msgSend`函数会依据接收者和选择子的类型来调用适当的方法. 该方法需要在接收者所属的类中搜寻其`方法列表`, 如果能够找到与选择子名称相同的方法则跳转到其实现代码, 如果找不到则沿着继承体系一直向上查找, 找到之后再跳转. 如果最终没有找到合适的方法, 则会执行`消息转发(message forward)`流程.

调用一个方法似乎要经历很多步骤. 所幸objc_msgSend会将匹配结果珲春在`快速映射表`中, 每个类都有这样一个缓存, 如果稍候还是向该类发送与选择子相同的消息, 那么执行起来就会很快. 实际上, 消息派发并非应用程序瓶颈所在.

## 12. 理解消息转发机制
1. 若对象无法响应某个选择子, 则进入消息转发流程;
2. 通过运行期的动态方法解析, 我们可以在需要用到某个方法时再将其加入类中;
3. 对象可以把其无法处理的选择子交给其它对象处理;
4. 经过上面两个步骤还是无法处理选择子, 那就启动完整的消息转发机制;

消息转发过程分为三个步骤:

**1.动态方法解析**

对象在收到无法解读的消息后, 首先将调用其所属类的下列类方法:`+ (BOOL)resolveInstanceMethod:(SEL)selter`. 该方法的参数就是那个选择子, 其返回值为bool类型, 表示此选择子是否能够新增一个实例方法处理这个选择子. 在继续往下转发之前, 本类由机会新增一个实例方法用以处理此选择子. 与此对应的类方法是: `+ (BOOL)resolveClassMethod:`.

**2.备援接收者**

当前接收者还有第二个机会处理未知的选择子. 运行期系统会询问它是否能够将这条消息转发给其它对象来处理. `- (id)forwardingTargetForSelector:(SEL)seltor`. 方法参数代表未知的选择子, 如果能够找到备援对象, 则将其返回即可, 找不到返回nil.

需要注意的是, 我们无法操作经此步骤所转发的消息. 如果想在消息法攻给备援对象之前修改消息内容,则需要通过完整的消息转发机制来处理.

**3.完整消息转发**

`- (void)forwardingInvocation:(NSInvocation *)invacation`. 此时能做的只有启动完整的消息转发机制. 首先创建NSInvacation对象, 将消息所有的细节都封装起来, `消息派发系统`将消息转发给目标对象.

完整的消息发送以及转发流程:

![1521098704578180-1.png](https://i.loli.net/2019/04/24/5cc020024d758.png)

## 13. 用`方法调配技术`调试`黑盒方法`
1. 在运行期可以向类中新增或者替换选择子所对应的方法;
2. 使用另一份实现来代替原有的方法实现, 这倒工序叫做`方法调配(method swizzling)`, 开发者常用此技术向原有实现中添加新功能;
3. 一般来说, 只有在调试程序时候才这么做, 这种方法不易滥用.

**原理:** 类方法列表会将选择子的名称映射到对应的方法实现上. 动态消息派发系统据此找到应该调用的方法. 这些方法以函数指针的形式存在, 我们可以在运行时改变不同选择子对应的方法实现(IMP), 据此实现方法调配.

**示例:**

```
BOOL best_Swizzle(Class aClass, SEL originalSel, SEL swizzleSel)
{
         // 如果originalSel没有实现过，class_getInstanceMethod无法找到该方法，所以originalMethod为nil
         Method originalMethod = class_getInstanceMethod(aClass, originalSel);
         Method swizzleMethod = class_getInstanceMethod(aClass, swizzleSel);
         BOOL didAddMethod = class_addMethod(aClass, originalSel, method_getImplementation(swizzleMethod), method_getTypeEncoding(swizzleMethod));
         if (didAddMethod) {
             //  当originalMethod为nil时，这里的class_replaceMethod将不做替换，所以swizzleSel方法里的实现还是自己原来的实现
             class_replaceMethod(aClass, swizzleSel, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
         } else {
             method_exchangeImplementations(originalMethod, swizzleMethod);
         }
         return YES;
}
```

## 14. 理解`类对象`的用意
1. 每个实例都有一个指向Class对象的指针, 用以表明其类型, 而这些Class类型则构成了类的继承体系;
2. 如果类型信息无法在编译期确定, 那么就应该使用类型信息查询方法来探知;
3. 尽量使用类型信息查询方法来探知对象类型, 而不要直接比较类对象, 因为这些对象可能实现了消息转发功能;

对于具体的oc类型,如果向其发送无法解读的消息编译器会产生警告, 而id类型,编译器假设它能够响应所有的消息.

id类型本身就是一个指针.

`isMemberOfClass:`能够判断出对象是否是某个特定的实例; `isKindOfClass:`能够判断某类型是否是其派生类的实例.


## 15. 使用前缀避免命名空间冲突
使用Cocoa编程需要注意, Apple宣称其保留使用所有"两个字母前缀"的权利, 所以我们编程的前缀应该是三个字母的.

## 16. 提供全能初始化方法
1. 在类中应该提供一个全能初始化方法(指定构造方法), 并于文档中指明. 其它初始化方法均应调用此方法.
2. 若全能初始化方法和超类不同, 则需复写超类中对应的方法.
3. 如果超类中初始化方法不能适用于子类, 则应该覆写这个超类方法并抛出异常.
## 17.使用description方法
1. 实现description方法返回一个有意义的字符串, 用以描述该实例;
2. 若想要在调试时打印出更详尽的对象描述信息, 则应该实现debugDescription;

一般情况下, 在新实现的description中应该像默认实现那样, 打印出类型的名字和指针地址, 因为这些内容有时候需要用到.

description和debugDescription的区别: 前者用于在代码中`NSLog`或者`print`函数输出信息; 后者用于断点调试输出信息.

## 18. 尽量使用不可变的对象
1. 尽量使用不可变的对象;
2. 若某属性仅用于对象内部修改, 则在`class-continuation`分类中将其由readonly修改为readwrite.
3. 不要把可变的collection作为属性进行公开, 而是提供相关方法, 以此修改对象中可变的collection.

## 19. 使用清晰协调的命名方式
1. 命名应当遵守Objective-C命名规范, 这样创建出来的接口更容易为开发者所理解;
2. 方法名应当言简意赅, 从左到右读起来像日常的句才好;
3. 方法名里不要使用缩略后的类型名称;
4. 给方法起名时第一要务是确保其风格与你自己的代码或所集成的框架相符.

## 20. 为私有方法名添加前缀
1. 给私有方法添加前缀, 这样可以容易的将其同公共方法做区分;
2. 不要用单一的下划线作为私有方法前缀, 因为这种做法是预留给苹果公司用的;

## 21. 理解Objective-C错误类型
1. 只有发生了可使整个应用程序崩溃的严重错误时, 才抛出异常;
2. 在错误不那么严重的情况下, 可以指派"外委托方法"来处理错误, 也可以把错误信息放在NSError对象里面, 经由"输出参数"返回给调用者.

Objective-C中, `自动应用计数`默认不是`异常安全的`. 这就意味着: `如果抛出异常, 那么本该在作用于末尾释放的对象, 现在不会自动释放了.` 可以通过编译器设置配置异常安全的异常, 但是程序员总是忘记这么做. 因此在iOS中处理异常问题.

Objective-C语言所采用的方法是: 只在及其罕见的情况下抛出异常, 异常抛出之后无需考虑恢复问题, 而且此时应应用程序应该直接退出.

## 22. 理解NSCopying协议
1. 若想要自己所写的对象具备拷贝功能, 则需要实现NSCopying协议.
2. 如果自定义对象分为可变版本和不可变版本, 那么需要同时实现NSCopying和NSMutableCopying协议.
3. 复制对象时选择使用深拷贝还是浅拷贝, 一般采用浅拷贝, 消耗资源更少.
4. 如果你的对象需要深拷贝, 可以写专门的方法来实现这个过程.

## 23. 通过委托与数据源协议进行对象间通信
1. 当某对象需要从另外一些对象中获取数据时, 可以使用委托模式. 
2. 嫁给你委托对象应该支持的接口定义成协议, 在协议中把可能需要处理的事件定义成方法.
3. Cocoa Touch中的`UITableViewDataSource`, `UICollectionViewDataSource`等等很多类似的实现.

## 24. 将类的实现代码分散于管理的数个分类中
1. 使用分类机制可以把类的实现代码划分为易于管理的小块;
2. 将应该视为私有的方法归入名叫private的分类中, 以隐藏实现细节;

## 25. 总是为第三方类的分类名称加前缀
1. 向第三方类型添加分类时, 总应给其名称加上你专用的前缀;
2. 向第三方类型添加分类时, 总应给其方法名加上你专用的前缀;

分类通常用于向无源码的既有类中新增功能. 分类中的方法是直接添加在类里面的, 他们就好比这个类中固有的方法. 将分类方法加入类中这一操作是在运行期系统加载分类时完成的. 运行期系统会把分类中每个方法都加入类型的方法列表中. **如果类中本来就有同名方法, 而分类中重新加入一份, 则新加入的方法会覆盖已存在的方法.** 实际上可能会发生多次覆盖, 多次覆盖结果以最后一个分类为准.

## 26. 勿在分类中声明属性
把封装数据所用的全部属性都定义在主接口中; 尽量不要在`class-continution分类`之外的分类中定义属性, 可以定义存取方法.

如果一定要定义, 则需要将属性声明成`@dynamic`, 也就是说, 这些方法在运行期提供. 这样可以在运行期拦截方法调用并提供其实现.

## 27. 使用`class-continution分类`隐藏实现细节
通过`class-continution分类`向类中新增实例变量; 如果某属性在主接口声明为只读, 而类的内部又要用设置方法修改此属性, 那么就在`class-continution分类`中将其扩展为可读写; 把私有方法的原型生命在`class-continution分类`中; 若想使类遵守的协议不为人所知, 则应该在`class-continution分类`中进行声明.

## 28. 通过协议提供匿名对象
1. 协议可在某种程度上提供匿名类型. 具体的类型可以淡化成遵守某协议的id类型, 协议里规定了对象所应实现的方法;
2. 使用匿名对象来隐藏类型名称(或类名);
3. 如果具体的类型不重要, 重要的是对象能够响应特定的方法(定义在协议里的方法), 那么可使用匿名对象来表示.

## 29. 理解引用计数
引用计数机制通过递增或者递减计数器来管理内存. 

引起循环应用的场景: Timer, block, delegate.

自动释放池的释放操作会在清空最外层的自动释放池时执行, 除非你又自己的自动释放池, 否则这个时机指的是当前线程的下一次事件循环.

## 30. 以ARC简化引用计数
1. 有了ARC之后, 程序员无需担心内存管理问题, 使用ARC编程, 可省去类中很多样板代码;
2. ARC管理对象声明周期的基本办法是: 在合适的地方插入`保留`和`释放`的操作. 在ARC的环境下, 变量的内存管理语义可以通过修饰符来指定, 而原来需要手动的执行保留和释放操作.
3. 由方法所返回的对象, 其内存管理语义总是由方法名来提现. ARC将此确定为开发者必须遵守的规范.
4. ARC只负责管理Objective-C对象的内存. 注意: CoreFoundation对象不归ARC管理, 开发者必须自己调用CFRetain/CFRelease.

## 31. 在delloc中只释放应用并解除监听
1. 在delloc中, 应该做的事情就是`释放指向其它应用的引用`, 并取消原来订阅的`键值观测`或`NSNoticationCenter通知`等, 不要做其它事情.
2. 如果对象持有文件系统资源, 则应该编写专门的方法来释放资源. 这样的类型和其它类要有个约定: 用完资源后必须调用close方法.
3. 执行异步任务的方法不应在delloc中调用; 只能在正常状态调用的方法也不应该在delloc方法中调用.

## 32. 编写`异常安全代码`留意内存管理问题
1. 捕获异常时, 一定要注意将try块内所创建的资源释放干净;
2. 在默认情况下, ARC不生成安全处理异常所需的代码. 开启编译器编译标志后, 可生成这种代码, 不过会导致应用程序变大, 运行效率变低. 因此在实际的项目开发中不推荐开启.

## 33. 以弱引用避免保留环
1. 将某些应用设置为weak可以避免`保留环`.
2. weak应用可以自动清空. 自动清空是随着ARC而引入的, 由运行期系统来实现. 在具备自动清空的弱引用上, 可以随意读取其数据, 因为这种应用不会指向已经回收过的对象.

## 34. 使用自动释放池降低内存峰值
自动释放池是以栈为结点实现的双向链表结构。对象收到autorelease之后，系统会将其放入最顶端的AutoreleasePoolPage的栈中。合理的利用自动释放池能够降低应用程序的内存峰值。

## 35. 使用僵尸对象调试内存管理问题
用于调试的方法，系统会修改对象的isa指针，使其指向僵尸类。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容以及接受者的消息，然后终止应用程序。

## 36. 不用使用retainCount
因为其返回值不可靠，被释放或者不存在的对象其返回值也可能是1. 对象可能在获取后的瞬间就被释放掉了，以此判断对象是否存在是不可靠的，在ARC中此方法被废止。

## 37. 理解'块'的概念
块可以分配在栈或堆上, 也可以是全局的. 分配在栈上的可以拷贝到堆上, 这样的话就和标准的oc对象一样了, 具备引用计数了.

块本身也是对象, 在存放块对象的内存区域中, 收个变量指向其Class对象的指针, 叫做isa指针. 其余内存里包含块对象运行最基本的各种信息.

在内存布局中, 最重要的是invoke变量, 它是个函数指针, 指向块的实现代码. 

## 38. 为常见的块类型创建typedef
* 用typedef重新定义块类型, 可以让块变量用起来更加简单.
* 可以为同一个块签名定义多个类型别名. 如果要重构的块使用了块类型的某个别名, 只需要修改相关的块签名即可, 不许改动其它typedef.

## 40. 用块引用其所属对象不要出现保留环
* 如果块所捕获的对象直接或者间接的保留了块本身, 那么需要当心保留环问题.
* 一定要找到合适的时机解除保留环, 而不能把责任推卸给调用者(思考地理位置信息反编码回掉的问题怎么解决).

## 41. 多用派发队列,少用同步锁
使用串行同步队列代替同步锁. 因为同步锁会消耗大量的资源, 比较耗时, 另外并不能保证完全的线程安全. 使用串行同步队列, 将需要操作的代码块放到同步队列中, 依次执行, 可以达到同步的效果. 

**执行异步派发时, 需要拷贝块, 会导致额外的耗时.**

**优化:** 使用并发队列和栅栏块. 分析发现, 读取操作并发执行并不会引起问题, 但是读取和写入操作不能同时执行, 因此读取操作可以直接放入并发队列中并发执行, 写入操作放入栅栏块中执行即可, 完美!

## 42. 多用GCD少用preformSelector系列方法
preformSelector系列方法在内存管理方面容易有疏漏. 它无法确定将要执行的选择子是什么, 因而ARC编译期也就无法插入适当的内存管理方法.

## 43. 掌握GCD以及操作队列的使用时机
虽然GCD非常强大, 在某些情况下还是有所不足的. NSOperationQueue实际上是GCD的面向对象版本, NSOperationQueue也有很多GCD所不具备的优点, 例如: 取消某个操作, 指定操作间的依赖关系, 指定操作的优先级, 重用NSoperation对象等.

## 45. 使用dispatch_once
分别采用@synchronize方式和dispatch_once实现单例, 后者的速度几乎是前者的两倍. 

编写一次性代码尽量使用dispatch_once

## 46. 不要使用dispatch_get_current_queue
尽量不使用这个方法.

## 47. 熟悉系统框架
多去熟悉几种常用的系统框架. 其中最重要的是Foundation框架和CoreFoundation框架, 它们为Cocoa/Cocoa Touch提供最基础得当支持.

## 48. 多用块枚举,少用for循环
* 遍历Collection有四种方式. 最基本的是使用for循环, 其次是NSEnumerator遍历法以及快读遍历法, 最新最先进的则是`块枚举法`.
* `块枚举法`本身就是通过GCD来并发执行遍历操作, 无需另行编写代码. 而采用其它遍历方法则无法轻易实现这点.

## 49. 对自定义其内存管理语义的collection使用无缝桥接
* 通过无缝桥接计数, 可以在Foundation框架的Objective-C对象与CoreFoundation框架的C函数数据结构之间来回切换.

## 50. 构建缓存使用NSCache而不是NSDictionary
*. 实现缓存功能时候, 应该使用NSCache而不是NSDictionary. 因为NSCache提供优雅的删减功能, 而且是`线程安全的`. 它与字典不同, 并不会拷贝键.

NSCache是线程安全的。

## 51. 精简initialize与load代码
* 在加载阶段, 如果类实现了load方法, 那么系统就会调用它. 分类中也可以定义此方法, 类的load方法要比分类中的load先调用. 与其它方法不同, load方法不参与覆写机制.
* 首次使用某个类之前, 系统会向其发送initialize消息. 由于此方法遵从普通的覆写规则, 所以通常应该咋里面判断当前要初始化哪个类.
* load和initialize方法都应该实现得精简一点, 这样有助于保持应用程序的响应能力, 也能避免引入依赖环的几率.
* 无法在编译期设定的全局常量, 可以在initialize中初始化.

需要注意的是, 整个应用程序在执行load方法时候都会被阻塞, 因此load实现要尽量的精简一些.

## 52.NSTimer循环应用问题
* NSTimer会保留其目标, 直到计时器本身失效为止, 调用invalidate方法可另计时器失效, 另外一次性计时器在触发任务之后也会失效.
* 反复执行任务的计时器, 很容易引入保留环, 如果这种计时器的目标对象又保留了计时器本身, 那肯定会产生保留环. 

解决NSTimer循环应用方案:

1. 使用第三方类型, 同时若引用NSTimer和Target对象.
2. 使用GCD的`dispatch_source_set_timer`代替NSTimer.
3. 使用Block, Block作为参数传入`scheduledTimerWithTimeInterval:`. 































1. 事件循环是什么? 发生在Runloop中的哪个步骤?