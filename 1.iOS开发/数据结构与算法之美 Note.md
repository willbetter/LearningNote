# 1.为什么要学习数据结构与算法

1. 为了通关大厂面试: 大厂面试都喜欢考算法, 现场写代码. 为了不跪在算法上, 需要好好学.
2. 不甘愿一辈子做业务代码: 虽然写业务代码的人很少需要自己实现数据结构和算法, 大部分时候都是使用别人的方法和框架. 但是不需要自己实现并不意味着什么都不需要了解. 写业务代码用到的很多第三方库都柔和了很多基础的数据结构和算法设计思想. 掌握数据结构与算法, 对于理解其背后设计思想非常有用. 理解第三方框架原理才能更好的使用第三方开源库.
3. 基础架构研发工程师,写出开源水平框架才是你的目标: 作为基础架构研发工程师, 只有了解数据结构和算法, 才能写出更好的基础组件.
4. 对编程的追求: 如果不想被行业淘汰, 就不要只写凑合能用的代码. 性能, 简装性, 可扩展性都是很重要的考量指标.

**掌握数据结构与算法, 你在看待问题的深度, 解决问题的角度都会完全不一样.** 这样的你, 就想式站在巨人的肩膀上, 拿着生存利器行走世界. 数据结构和算法, 会为你的编程之路, 甚至人生之路打开一扇通向新世界的大门. 

# 2.如何抓住重点, 高效的学习数据结构与算法
数据结构就是指一组数据的存储结构. 算法是操作数据的一组方法. 数据结构和算法是相辅相成的, 数据结构是为算法服务的, 算法要作用在特定的数据结构之上. 因此, 我们无法孤立数据结构来讲算法, 也不发孤立算法来讲数据结构.

要想掌握数据结构与算法, **最重要的是: 掌握复杂度分析.** 它有多重要呢? 几乎占据数据结构与算法的半壁江山. 

数据结构与算法知识点如下图所示:

![](images/913e0ababe43a2d57267df5c5f0832a7.jpg)

这里有王峥老师推荐的20个最常用的最基础的数据结构与算法, 不管事应付面试还是工作需要, 只要逐一功课这20个知识点就足够了. 10个数据结构:数组,链表,栈,队列,散列表,二叉树,堆,跳表,图,Trie树; 10个算法:递归算法,排序,二分查找,搜索,哈希算法,贪心算法,分治算法,回溯算法,动态规划,字符串匹配算法.

事半功倍的学习技巧:

1. 边学边练,适度刷题: 把每节课上涉及到的习题都自己敲一遍. 对于刷题, 一定要适度, 海量的刷题可能反而会导致你对数据结构和算法失去信心.
2. 多问,多思考,多互动: 不懂得有疑问的地方, 找人一块学习探讨.
3. 知识需要沉淀, 不要想视图一下子掌握所有: 学习知识的过程是反复迭代不断沉淀的过程, 看不懂就反复看,反复练, 自己搞不懂的就问别人, 问google.

# 3.算法的复杂度分析
## 3.1 什么是时间复杂度
**复杂度分析是这个那个算法学习的精髓, 只要掌握了它, 数据结构与算法的内容基本上就掌握了一半.**

**为什么需要复杂度分析?** 因为真机上测试结果非常依赖测试环境, 同样算法在不同cpu/内存上运行时间可能不同. 测试的结果受数据规模的影响比较大, 如果数据规模非常大, 根本无法在真机上进行实际测试(比如跑一遍需要数年的算法). 

我们需要一个不用具体的测试数据来测试, 就可以粗略估计算法执行效率的方法. 这就是时间/空间复杂度分析方法.

## 3.2 大O复杂度表示法
大O时间复杂度实际上并不具体表示代码真正的执行事件, 而是表示**代码执行时间随数据规模增长的变化趋势**, 因此也称为**渐进时间复杂度**, 简称时间复杂度.

**如何分析一个算法时间复杂度?** 

1. 只关注循环次数最多的一段代码. 大O时间复杂度表示的是一种变化趋势, 我们通常会忽略掉公式中的常量, 低阶, 系数, 只要记录一个最大阶的量级就可以了. **所以我们在分析一个算法, 一段代码的时间复杂度时候, 只关注循环此书最多的一段代码就可以了**.
2. 加法法则:**总时间复杂度等于量级最大的那段代码的复杂度.** 
3. 乘法法则:**嵌套代码的复杂度等于嵌套内外代码复杂度的乘积.**

## 3.3 几种常见的事件复杂度分析示例
![](images/3723793cc5c810e9d5b06bc95325bf0a.jpg)

1. **O(1):**一般情况下, 只要算法不存在循环, 递归, 即使有成千上万行的代码, 其时间复杂度也是O(1).
2. **O(log n),O(n\*log n):**2^x=n 则x=log2n. 这也是比较常见的时间复杂度, 归并排序,快速排序的时间复杂度都是O(nlogn).
3. **O(m+n),O(m\*n):**当无法确定m和n的量级哪个更大时候, 则两者都要考虑.

## 3.4 最好/最坏时间复杂度
顾名思义, **最好时间复杂度指最理想情况下, 执行代码的时间复杂度. 最坏时间复杂度指最糟糕情况下, 执行代码的时间复杂度.**

## 3.5 平均时间复杂度
**平均时间复杂度全称是加权平均时间复杂度或者期望时间复杂度.** 是使用概率论中方法计算出来的时间复杂度.

大多数情况下, 我们并不需要区分最好/最坏/平局时间复杂度. 只有同一块代码在不同情况下, 时间复杂度有量级的差距, 我们才会使用这三种复杂度表示来区分.

## 3.6 均摊时间复杂度
**使用摊还分析法得到的时间复杂度叫做均摊时间复杂度.**

实际上**均摊时间复杂度就是一种特殊的平均时间复杂度**, 我们没必要话费太多精力区分它们. 关键是掌握它的分析方法: **摊还分析法.**

## 3.7 空间复杂度
**空间复杂度实际上是渐进空间复杂度. 表示的是算法的存储空间随着数据规模之间的增长关系.**

## 3.8小结

集中时间复杂度的渐进增长图:

![](images/497a3f120b7debee07dc0d03984faf04.jpg)

# 4.数组:为什么很多编程语言数组都从0开始?
**数组是一种线性表数据结构. 它用一组连续的内存空间, 来存储一组具有相同类型的数据.** 

**线性表:** 线性表是指数据排成一条线一样的结构. 每个线性表的数据最多只有向前和向后来给你个方向. 除了数组, 链表, 队列, 栈等都是线性表.  **非线性表:** 二叉树, 图堆等. 之所以叫非线性表, 因为数据之间并不是简单的前后关系.

**连续内存空间相同数据类型:** 正是因为有了这两个特性, 它才有了堪称杀手锏的特性: **随机访问.**

数组随机访问的特性带来的缺点就是低效的插入和删除. 因为插入和查出设计到数据的移动. 

容器最大的好处是可以将很多数组操作的细节封装起来, 比如插入删除时候的数据移动. 另外容器一般支持动态扩容. **如果我们事先知道数组的最大容量, 那么我们最好指定数组的容量, 这样可以避免数据搬迁带来的额外开支.
**

**为什么数组编号从0开始呢?** 从数组存储的内存模型上看, 下标最确切的定义应该是"偏移". 因此使用0开头会更好一点. 更大的可能是历史原因造成的, C语言设计者使用0开始数组下标, 之后其它语言都效仿了C语言.

# 5.链表:如何实现LRU缓存淘汰算法
缓存是一种提高数据读取性能的技术, 在计算机领域有着广泛的应用. 缓存大小有限, 当缓存被用满时, 哪些数据被清除, 哪些被保留需要缓存淘汰策略决定. 常见的策略有三种: **先进先出策略FIFO**(First In, First Out), **最少使用策略LFU**(Least Frequently Used), **最近最少使用策略LRU**(Least Recently Used).

**链表相关概念:**

链表通过指针将一组零散的内存块串联在一起. 我们把内存块称为链表的**结点**. 内存块中记录链上下一个结点地址的指针称为**后继指针**, 记录前一个结点的指针叫做**前驱指针**. 我们习惯把链表的第一个结点称为**头结点**, 把最后一个结点称为**尾结点**. 尾结点指向头结点的链表称为**循环链表**. 

**如何实现一个LRU淘汰算法?**

思路: 维护一个有序单链表, 越靠近链表尾部的结点是越早之前访问的. 当有新的数据被访问时, 我们从链表头开始顺序遍历链表.

1. 如果此数据之前已经被缓存在链表中了, 我们得到这个数据对应的结点, 将其从原来的位置删除, 然后再插入到链表的头部. 
2. 如果吃数据没有在缓存列表中. 如果此时缓存未满, 则将结点插入到链表头部; 如果链表已满,则删除尾结点并将数据插入到头部.

以上LRU的实现, 不管结点是否存在都需要遍历一遍, 查找时间复杂度是O(n), 这里可以使用哈希表的方式进行缓存, 可以更快速的查找.

CPU在读取数据时候, 会把读到的数据加到CPU缓存中, 而cpu每次从内存中读取数据并不是只读取特定的地址, 而是读取一个数据块并保存在cpu缓存中, 然后下载访问就会先从cpu缓存中取, 取不到再去内存中取. 数组占用内存空间是连续的, 可能一次性读取多个数据到cpu缓存中, 而链表数据是不连续的, 无法享受到cpu缓存机制带来的好处.

# 6.链表:如何轻松正确的写出链表代码

1. 理解指针和应用的含义. 将某个变量赋值给指针时机上就是将这个变量的地址赋值给指针, 或者反过来说, 指针中村村了这个变量的内存地址, 指向这个变量, 通过指针就能找到这个变量.
2. 警惕指针丢失和内存泄露. 在插入或者删除结点时候一定要注意插入或者删除的顺序, 谨防指针丢失.
3. 利用哨兵简化实现难度. 针对链表的插入/删除操作, 需要对插入的第一个结点和删除最后一个结点情况特殊处理, 这样实现起来繁琐不简洁. 我们可以针对性的引入**哨兵结点**(包含哨兵结点的链表称为带头链表). 
4. 重点关注边界条件. 空链表能否正常运行? 一个结点是否正常? 两个结点是否正常? 处理头结点和尾结点是否正常?
5. 举例画图,辅助思考. 想不明白的地方, 多举例画图, 更加直观.
6. 多写多练. 

链表相关练习题目(对应leet编号:206，141，21，19，876):

1. 单链表反转;
2. 链表中环的检测;
3. 两个有序链表的合并;
4. 删除链表中倒数第n个节点;
5. 求链表的中间结点;




























