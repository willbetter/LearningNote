设计模式-Note 
--------------
**目录**

- [1.设计原则](#1设计原则)
- [2.六个创建型模式](#2六个创建型模式)
    - [2.1 简单工厂模式](#21-简单工厂模式)
    - [2.2 工厂方法模式](#22-工厂方法模式)
    - [2.3 抽象工厂模式](#23-抽象工厂模式)
    - [2.4 单例模式](#24-单例模式)
    - [2.5 原型模式](#25-原型模式)
    - [2.6 建造者模式](#26-建造者模式)
- [3.七个结构型模式](#3七个结构型模式)
    - [3.1 适配器模式](#31-适配器模式)
        - [3.1.1 对象适配器](#311-对象适配器)
        - [3.1.2 类适配器](#312-类适配器)
        - [3.1.3 小结](#313-小结)
    - [3.2 桥接模式](#32-桥接模式)
    - [3.3 组合模式](#33-组合模式)
    - [3.4 装饰模式](#34-装饰模式)
    - [3.5 外观模式](#35-外观模式)
    - [3.6 享元模式](#36-享元模式)
    - [3.7 代理模式](#37-代理模式)
- [4.十一个行为型模式](#4十一个行为型模式)
    - [4.1 责任链模式](#41-责任链模式)
    - [4.2 命令模式](#42-命令模式)
    - [4.3 解释器模式](#43-解释器模式)
    - [4.4 迭代器模式](#44-迭代器模式)
    - [4.5 中介者模式](#45-中介者模式)
    - [4.6 备忘录模式](#46-备忘录模式)
    - [4.7 观察者模式](#47-观察者模式)
    - [4.8 状态模式](#48-状态模式)
    - [4.9 策略模式](#49-策略模式)
    - [4.10 模板方法模式](#410-模板方法模式)
    - [4.11 访问者模式](#411-访问者模式)
- [5.其它](#5其它)

**重点:** 六大设计原则, 
# 1.设计原则

* **单一职责原则**. 一个类只负责一件事.
* **开闭原则**. 对修改关闭, 对扩展开放.
* **接口隔离原则**. 使用多个专门的协议, 而不是一个庞大臃肿的协议; 协议中方法尽量精简. 例如,UITableViewDelegate,UITableViewDataSource使用两个协议而不是一个协议, 这样更符合接口隔离原则.
* **依赖倒置原则**. 抽象不不应该依赖具体实现, 具体实现可以依赖于抽象.
* **里氏替换原则**. 父类可以被之类无缝替换, 且原有功能不受影响. (KVO遵从了这个法则,无缝使用子类)
* **迪米特法则**. 一个对象应当对其它对象尽可能少的了解. 高内聚,低耦合.

# 2.六个创建型模式
## 2.1 简单工厂模式
## 2.2 工厂方法模式
## 2.3 抽象工厂模式
## 2.4 单例模式
## 2.5 原型模式
## 2.6 建造者模式

# 3.七个结构型模式
## 3.1 适配器模式
> **例子:** 笔记本电脑工作电压是20V, 我国家庭用电电压是220V, 他们之间无法直接连接, 这时候就需要一个适配器来适配两者的工作, 这就引入了电源适配器. 

![](images/1362066387_9870.jpg)

**适配器模式**: 将一个接口转换成客户希望的另一个接口, 使接口不兼容的哪些类型可以一起工作, 其别名为包装类. 适配器模式既可以作为类结构型模式, 也可以作为对象结构型模式. 

**在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。**
### 3.1.1 对象适配器
**对象适配器模式类图:**

![](images/1362066399_9469.jpg)

Adapter继承自目标抽象类, 实现request方法. Adapter引用了Adaptee, 在其request中调用需要适配的方法.

### 3.1.2 类适配器
类适配器模式和对象适配器模式最大的不同时适配器与适配者的关系不同, 对象适配器模式中适配器与适配者是关联关系; 类适配器中适配器与适配者是继承关系, 类适配器类图如下所示:

![](images/1362099343_7447.jpg)

Adapter继承自Adaptee, 实现了目标协议的request协议方法, 在方法内部调用适配者相关的方法, 完成适配工作.

### 3.1.3 小结
**优点:** 

1. 将目标类和适配者类解耦, 通过引入一个适配者类来重用现有的适配者类, 无需修改原有结构.
2. 增加类的透明性和复用性. 将具体的业务封装在适配者类中, 对客户端而言是透明的, 提高了适配者的复用性.

**使用场景:**

1. 系统需要使用一些现有的类, 而这些类的接口(方法名)不符合系统的需要, 甚至没有这些类的源代码.
2. 向创建一个可以重复使用的类, 用于与一些彼此没有太大关联的类, 包括一些可能将来需要引进的类一起工作.的.

## 3.2 桥接模式
> 示例: 设计一款跨平台的图片解压程序. 不同的图片格式是一个变化的纬度, 不同的操作系统平台又是一个变化的纬度. 这时候我们需要使用桥接模式, 将两者的变化连接起来.

![](images/1334506504_5936.gif)

**桥接模式:** 将抽象部分和它的实现部分分离, 使他们可以独立的变化. 它是一种对象结构型模式, 又称为柄体模式或者接口模式.

**桥接模式用于软件系统中某个类存在两个独立变化的纬度, 通过该模式将两个或者多个纬度的变化分离开来, 使两者可以独立扩展**, 让系统更加符合"单一职责原则". 它将两个独立变化的纬度设计为两个独立的继承等级结构, 并且在抽象层简历抽象关联, 该关联关系类似一条链接两个独立继承结构的桥, 故称桥接模式.

**桥接模式类图:**

![](images/1334505919_5277.gif)

**桥接模式和适配器模式配合使用**, 示例类图如下所示:

![](images/1334507018_4999.gif)

读取excel报表的程序需要使用ExcelAPI, 这时候通过一个适配器关联读取API类的对象, 在响应的方法中调用读取方法.

**优点:**

1. 分离抽象接口和实现部分. 桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。
2. 取代多重继承方案.
3. 提高系统扩展性, 在两个变化纬度中任意扩展一个纬度, 都不需要修改原有系统, 符合"开闭原则".

## 3.3 组合模式
**组合模式为处理树形结构提供了一种较为完美的解决方案, 它描述了如何将容器和叶子进行递归组合, 使得用户再使用时无需对他们进行区分, 可以一致的对待容器和叶子.**

**组合模式:** 组合多个对象形成树形结构以表示具有"整体-部分"关系的层次结构. 组合模式对整个对象和组合对象的使用具有一致性, 组合模式又称为"整体-部分"模式, 是一种对象结构型模式.

组合模式类图如下所示:

![](images/1347029718_6268.jpg)

组合模式的关键是定义一个抽象构件类, 它既可以代表叶子, 也可以代表容器. 而客户端针对该抽象构件类进行编程, 无需知道它到底表示的是叶子还是容器, 可以对他们统一处理.

**组合模式在Cocoa框架中最重要的应用在页面布局通用行为的UIView这个类上. 视图层级中的单个视图对象可能是叶子结点, 也可以是包含其它视图集合的composite对象.**

**优点:**

1. 组合模式可以清楚地定义分层次的复杂对象, 表示对象的全部或者部分层次, 让客户端忽略层次的差异, 方便对这个那个层次结构进行控制.
2. 在组合模式中增加新的容器构建和叶子构件都很方便, 无需对现有类进行修改, 符合"开闭原则".
3. 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案.

**使用场景:**

1. 在一个面向对象语言开发的系统中需要处理一个树形结构.
2. 在具有整体和部分的层次结构中, 希望通过一种方式忽略整体和部分的差异, 客户端可以一致的对待它们.

## 3.4 装饰模式
**装饰模式:** 动态的给一个对象增加一些额外的职责, 就增加对象功能来说, 装饰模式比生成子类实现更加灵活. 装饰模式是一种对象结构型模式.

装饰器模式类图:

![](images/1333528185_7832.gif)

由于具体构建类和装饰器类都实现了相同的抽象接口, 因此装饰器模式以对客户透明的方式动态给一个对象附加更多责任, 而客户端并不会觉得对象在装饰前和装饰后有什么不同. 装饰模式可以在不需要更多子类的情况下, 对对象的功能加一扩展.

装饰器模式可以多层嵌套, 每个装饰器实现不同的新功能, 并包装旧的装饰器或者原始类, 这一切对客户端来说都是透明的.

![](images/WX20190529-142102@2x.png)

**优点:**

1. 对于扩展一个对象的功能, 装饰模式比继承更加灵活, 不会导致类数量急剧增加.
2. 可以通过一种动态的方式扩展一个对象功能. 
3. 可以对一个对象进行多次装饰, 通过使用不同的具体装饰类的排列组合, 可以创造出很多不同的行为组合, 得到功能更加强大的对象.

**使用场景:**

1. 在不影响其它对象的情况下, 以动态透明的方式给单个对象添加职责.
2. 当不能采用继承方式进行扩展, 或者扩展将产生大量子类的情况下.

## 3.5 外观模式
**外观模式:** 为子系统的一组接口提供一个统一的入口. 外观模式定义了一个高层的接口, 这个借口使得这一子系统更容易使用.

外观模式中, 一个子系统的外部与其内部通信通过一个统一的外观类进行, 外观类将客户类与子系统的内部复杂性分割开, 使得客户类只需要与外观角色打交道, 而不需要与子系统内部的很多对象打交道. **外观模式是迪米特法则的具体实现, 通过引入外观角色可以降低原有系统的复杂度, 同时降低客户类与子系统耦合度.**

外观模式类图如下所示:

![](images/1354636733_5965.jpg)

**优点:**

1. 降低子系统和客户端之间的耦合;
2. 对客户端屏蔽了子系统组件, 减少客户端所需处理的对象数目, 使子系统使用起来更加方便;
3. 一个子系统的修改对其它子系统没有影响;

**使用场景:**

1. 为一系列复杂的子系统提供一个简单入口时候可以用外观模式;
2. 客户端与多个子系统之间存在很大的依赖性;
3. 层次化结构中, 可以用外观模式定义系统每一层的入口;

## 3.6 享元模式
> 示例: 享元模式在Cocoa Touch的应用是`UITableViewCell`, `UICollectionViewCell`的复用.

**享元模式:** 运用共享技术有效的支持大量细粒度对象的复用. 系统只使用少量对象, 而这些对象都很相似, 状态变化很小, 可以实现对象的多次复用. 由于享元模式要求能够共享的对象必须是细粒度的对象, 因此它又称为轻量级模式, 它是一种对象结构型模式.

享元模式结构比较复杂, 一般结合工厂模式一起使用, 在它的结构图中包含了一个享元工厂类, 其类图如下所示:

![](images/1339770628_5970.jpg)

享元模式中引入了享元工厂类, 享元工厂类的作用在于提供一个存储享元对象的享元池, 当用户需要对象时, 首先从享元池中获取, 如果享元池中不存在, 则创建一个新的享元对象返回给用户, 并在享元池中保存该对象. 典型的享元工厂类代码如下所示:

```java
class FlyweightFactory {
    //定义一个HashMap用于存储享元对象，实现享元池
       private HashMap flyweights = newHashMap();
       public Flyweight getFlyweight(String key){
              //如果对象存在，则直接从享元池获取
              if(flyweights.containsKey(key)){
                     return(Flyweight)flyweights.get(key);
              }
              //如果对象不存在，先创建一个新的对象添加到享元池中，然后返回
              else {
                     Flyweight fw = newConcreteFlyweight();
                     flyweights.put(key,fw);
                     return fw;
              }
       }
}
```

**优点**

1. 可以极大减少内存中对象的数量, 使得相同或者相似对象在内存中只保留一份, 从而节约系统资源, 提高系统性能.
2. 享元模式的外部状态相对独立, 而且不会影响其内部状态, 从而使得享元对象可以在不同环境中被共享.

**使用场景**

1. 一个系统中存在大量相同或者相似的对象, 造成内存的大量消耗.
2. 对象的大部分状态都可以外部化, 可以将这些外部状态传入对象中.
3. 在使用享元模式时候需要维护一个共享的享元对象池不, 而这需要消耗一定的系统资源, 因此, 应当在需要多次重复使用享元对象时候吃啊值得使用享元模式.

## 3.7 代理模式
**代理模式:** 给某一个对象提供一个代理或者占位符, 并由代理对象来控制对原对象的访问.

代理模式类图如下所示:

![](images/1353942400_6301.jpg)

**优点**

1. 能够协调调用者和被调用者, 在一定程度上降低系统的耦合度.
2. 客户端针对抽象主题编程, 增加和更换代理类无序

# 4.十一个行为型模式
## 4.1 责任链模式
**责任链模式:** 避免请求发送者和请求接收者耦合在一起, 让多个对象都有可能接收请求, 将这些对象链接成一条链, 并且沿着这条链传递请求, 直到有对象处理它为止. 责任链模式是一种对象行为型模式.

![](images/1333307613_2407.gif)

具体的处理者是抽象处理者的子类, 它有两大作用: 处理请求或者转发请求:

```
class ConcreteHandler extends Handler {
	public void handleRequest(String request) {
		if (请求满足条件) {
			//处理请求
		}
		else {
			this.successor.handleRequest(request);  //转发请求
		}
	}
}
```

责任链模式的关键在于对调用组件隐藏了责任链上单个链的实现细节. 责任链的创建可以放在客户端, 也可以放在责任链的基类中, 根据枚举类型创建不同的责任链.(放在客户端创建责任链可能更好一点, 更加符合开闭原则)

**应用:**

1. Cocoa框架中使用责任链来处理用户界面事件. 所有UI组件都派生自UIResponder类. 每个UI组件都是责任链中的链, 他们的位置反应的是其在界面组件层级关系中的位置, 层级顶端是责任链中的最后一个链.
2. 车主邦App中, Bundle图片获取器通过责任链模式实现. 如果是二倍屏, 则先获取二倍图, 没有的话获取三倍图, 一倍图. 
3. 消息处理也可以作为责任链来开发. 当收到一个消息, 把消息传递给第一个处理器, 如果不能处理则传递给第二个处理器...

**使用场景:** 当多个对象可以响应一个请求, 而最终只有一个对象会处理请求时, 可以使用此设计模式.

## 4.2 命令模式

> 例子: 有一个模拟遥控器的页面, 遥控器面板上有几十种不同的功能. 针对这样的需求, 我们可以使用命令模式, 实现具体的命令类型, 包装具体的操作, 命令发送者只需针对抽象命令类编程, 最后把具体命令类和命令发送者关联起来. 

命令模式可以将请求发送者和接收者完全解耦, 发送者和接收者之间没有直接引用关系, 发送请求的对象只需直到如何发送请求, 而不必知道如何完成请求.

**命令模式: 将一个请求封装成一个对象, 从而让我们可用不同的请求对客户进行参数化; 对请求排队或者记录请求日志, 以及支持可撤销的操作. 命令模式是一种对象行为型模式.**

![](images/1366033467_9048.jpg)

**命令模式的本质是对请求进行封装, 一个请求对应于一个命令, 将发出命令的责任和执行命令的责任分割开.** 每个命令都是一个操作: 请求的一方发出请求要求执行一个操作; 接收的一方收到请求, 并执行相应的操作. **命令模式允许请求的一方和接收的一方独立开来, 使得请求的一方不必知道接收请求方的接口, 更不必知道请求如何被接收, 操作是否被执行, 何时被执行, 以及怎么被执行. **

命令模式的关键在于引入了抽象命令类, 请求发送者针对抽象命令类编程, 只有实现了抽象命令类的具体命令才与请求接收者相关联. 

命令模式是一种使用频率非常高的设计模式, 它可以将请求发送者和接收者解耦, 请求发送者通过命令对象来间接引用请求接收者, 使得系统具有更好的灵活性和可扩展性. 

**优点**

1. 降低系统耦合度. 由于请求者和接收者之间不存在直接引用, 因此请求者和接收者实现了完全的解耦, 相同的请求者可以对应不同的接收者, 反之亦然.
2. 新的命令可以很容易的加入到系统中.
3. 可以比较容易的设计一个命令队列或者组合命令.
4. 为请求的撤销和恢复提供了一种设计和实现方案.

## 4.3 解释器模式(了解)
解释器模式是一种使用频率相对较低但学习难度较大的设计模式, 其用于描述如何使用面向对象语言构建一个简单的语言解释器. 再某些情况下, 为了更好描述某一些特定的问题, 我们可以创建一种新的语言, 这种语言拥有自己的表达式和结构, 即文法规则, 这些问题的实例将对应该语言中的句子. 此时可以使用解释器设计新的语言. 对解释器模式的学习能够加深我们对面向对象思想的理解, 并掌握编程语言中文法规则的解释过程.

**解释器模式: 定义一个语言的文法, 并且建立一个解释器来解释该语言中的句子, 这里的语言指使用规定格式和语法的嗲吗. 解释器是一种类行为型模式.**

![](images/1341331467_7271.jpg)

解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释语言中的句子。虽然解释器模式的使用频率不是特别高，但是它在正则表达式、XML文档解释等领域还是得到了广泛使用。与解释器模式类似，目前还诞生了很多基于抽象语法树的源代码处理工具，例如Eclipse中的Eclipse AST，它可以用于表示Java语言的语法结构，用户可以通过扩展其功能，创建自己的文法规则。

## 4.4 迭代器模式
## 4.5 中介者模式
如果一个系统中对象之间存在多对多的相互关系, 我们可以将对象的一些交互行为从各个对象中分离开来, 并几种封装在一个中介者对象中国, 并由该中介者进行统一协调, 这样对象之间多对多的复杂关系就转化成相对简单的一对多关系. **中介者模式是`迪米特法则`的一个典型应用.**

![](images/1357651865_7741.jpg)

**中介者模式:** 用一个中介对象来封装一系列的对象交互, 中介者使各对象不需要显式地相互引用, 从而使其耦合松散, 而且可以独立地改变他们之间的交互. 中介者模式又称为调停者模式, 它是一种对象行为模式.

![](images/1357651874_7064.jpg)

再中介者模式中, **中介者承担两方面的责任**:

1. **中转作用:** 通过中介者模式提供的中转作用, 各个同事对象就不需要显式的应用其它同事, 当需要和其它同事进行通信时, 可通过中介者来间接调用. 
2. **协调作用:** 中介者可以进一步对同事之间关系进行封装, 同事可以一致的和中介者进行交互, 而不需要指明中介者需要怎么做, 中介者根据封装在自身内部的协调逻辑, 对同事的请求进行进一步的处理.

**优点**

1. 简化了对象之间的交互.
2. 可将各同事对象解耦.
3. 减少生成子类. 

**适用场景**

1. 系统中对象之间存在复杂的引用关系, 系统结构混乱且难以理解.
2. 一个对象由于引用了其它很多对象并且直接和这些对象通信, 导致难以复用该对象.
3. 想要通过一个中间类来封装多个类的行为, 而不想生成太多的子类. 可以通过引入中介者类来实现. 


## 4.6 备忘录模式
备忘录模式提供可一种状态恢复实现机制 , 使用户可以方便的回到一个特定的历史步骤, 当新的状态无效或者存在问题时, 可以使用暂时存储起来的备忘录将状态恢复.

**备忘录模式:** 在不破坏封装的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态, 这样可以在以后将这个对象恢复到原先保存的状态. 他是一种对象行为型模式. 

![](images/1335891550_5966.jpg)

如上图所示, **原发器(Originator)相当于需要被保存状态的对象, 比如一个象棋的棋子; 备忘录(Memento)相当于是是保存棋子位置类型等属性的数据Model, 纯粹用来存储数据的; 负责人(Caretaker)相当于是一个管理类型, 管理人会调用原发器, 生成一个备忘录对象, 管理人也可以根据备忘录对象恢复一个原发器历史的状态.**

在设计备忘录模式时要考虑其封装性, **除了Originator类, 不允许其它类来调用备忘录类的Memento的构造函数与相关方法.** 否则可能导致备忘录在保存的历史状态发生改改变, 这样备忘录模式就失去了意义.

**优点**

1. 提供了一种状态恢复的实现机制, 使用户可以方便的回到一个特定的历史步骤, 当新的状态无效或者存在问题时, 可以使用展示存储起来的备忘录将状态复原.
2. 备忘录实现了对信息的封装, 一个备忘录对象是一种原发器对象状态的标识, 不会被其它代码所改动. 备忘录保存了原发器的状态, 吃啊用列表, 堆栈等集合来存储备忘录对象可以实现多次撤销操作.

**使用场景**

1. 保存一个对象在某一个时刻的全部状态或部分状态, 周鹤洋以后需要时候它能够恢复到先前的状态, 实现撤销操作.
2. 防止完结对象破坏一个对象历史状态的封装性, 避免将对象历史状态的实现细节暴露给外界.

## 4.7 观察者模式
观察者模式是使用频率最高的设计模式之一, 它用于建立一种对象之间的依赖关系, 一个对象发生改变时将自动通知其它对象, 其它对象做出响应. 观察者模式中, 发生改变的对象称为观察目标, 被通知的对象称为观察者, 一个观察目标可以对应多个观察者, 而这些观察者之间可以没有任何相互联系, 可以根据需要增加或者减少观察者,使系统易于扩展. 

**观察者模式: 定义对象之间的一种多对多依赖关系, 使得每当一个对象状态发生改变时, 其相互依赖对象皆可得到通知并被自动更新. 观察者模式是一种对象行为型模式.**

![](images/1341501815_4830.jpg)

**观察者与MVC**

MVC架构中应用了观察者模式. 其中模型对英语观察者模式中的目标, 而视图适用于观察者, 控制器残党两者的中介者. 当模型层的数据发生改变时, 视图层将自动改变其显示内容. 

**优点**

1. 观察者模式可以实现表示层和数据逻辑层的分离, 定义了稳定的消息更新传递机制, 并抽象了更新接口,使得可以有各种各样不同的表示层重放具体观察者角色.
2. 观察者模式 在观察目标和观察者之间建立一个抽象的耦合. 观察目标只需维护一个抽象观察者的集合, 无需了解具体观察者, 实现解耦.
3. 观察者模式支持广播通信, 观察哈目标会向所有已注册的观察者对象发送通知, 简化了一对多的系统设计难度.
4. 满足开闭原则的要求, 增加新的具体观察者无序修改原有系统代码, 增加新的观察目标也很方便.

## 4.8 状态模式
> 例子: Cocoa Touch中使用状态模式最典型的应用是UIButton再不同状态下表现不同. 这里状态的切换是由UIButton(Context类)的点击事件或者配置来实现切换的, 使用currentState表示当前状态, 不同状态展示不同的状态.

状态模式**用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题**. 当系统中某个对象存在多个状态, 这些状态之间可以进行转换, 而且对象在不同状态下行为不相同时可以使用状态模式. 状态模式将一个对象的状态从该对象中分离出来, 封装到专门的状态类中, 使得对象状态可以灵活变化, 对于客户端而言, 无需关心对象状态的转换以及对象当前所处当前状态, 无论对于何种状态的对象, 客户端都一致处理.

**状态模式: 允许一个对象在其内部状态改变时改变它的行为, 对象看起来似乎修改了它的类. 状态模式是一种对象行为型模式.**

![](images/1358693242_5100.jpg)

在状态模式中, 我们将对象在不同状态下的行为封装到不同的状态类中, 为了让系统具有更好的灵活性和可扩展性, 同时对各状态下的共有行为进行封装, 我们需要将状态进行抽象.

在状态模式中, 一个对象的状态之间可以进行相互转换, 通常有两种状态转换方式:

1. 统一由环境类负责状态之间的转换(上图从的Context类,声明`chargeState`方法), 根据需要进行状态切换;
2. 由具体状态类负责状态之间转换. 在具体的状态类的业务方法中判断环境类的某些树形, 再根据情况为环境类设置新的状态对象, 实现状态转换. **同样也可以提供专门的方法负责属性值的判断和状态转换(KVO监听变化).**

某些情况下, 多个环境对象可能需要共享同一个状态, 如果希望在系统中实现多个环境对象共享一个或多个对象, 那么需要将这些状态定义为环境类的静态成员对象.

## 4.9 策略模式

> 举例: 一个项目中的实例就是对消息推送的组件化封装. 在推送消息组件中封装第三方消息, 推送组件包含了消息处理的管理类型和处理过程的接口. 再实际使用时候去实现协议, 定义具体的处理流程, 然后配置到管理类型中. 推送管理类型负责与具体推送服务做交互.

实现某一个功能有多条途径, 每一条途径对应一种算法, 此时我们可以使用一种设计模式来实现灵活的选择解决途径, 也能够方便的增加新的解决途径.

**策略模式:** 定义一系列算法类, 将每一个算法封装起来, 并让他们相互替换, 策略模式让算法独立于它的客户而变化, 也称为政策模式. 策略模式是一种对象行为型模式.

![](images/1343811032_3729.jpg)

**策略模式的主要目的是嫁给你算法的定义和使用分开, 也就是将算法的行为和环境分开.** 

**优点**

1. 策略模式提供对"开闭原则"的完美支持, 用户可以在不修改原有系统的基础上选择算法和行为, 也可以灵活的增加新的算法和行为.
2. 策略模式提供了管理相关算法簇的办法. 
3. 策略模式提供了可以替代继承关系的办法. 使用组合代替继承.

**使用场景**

1. 一个系统需要动态的几种算法中选择一种, 那么可以将这些算法封装到一个个的具体算法类中, 而这些具体算法类都是抽象算法类的子类.
2. 一个对象有很多种行为, 如果不用恰当的模式, 这些行为就只好使用多重条件语句来进行实现.
3. 不希望客户端直到复杂的, 与算法相关的数据结构, 再具体策略类中封装算法和相关的数据结构, 可以提高算法的保密性和安全性.

## 4.10 模板方法模式
**模板方法模式**: 定义一个操作中算法的框架, 而将一些步骤延迟到子类中. 模板方法模式可以使得子类可以不改变一个算法结构即可重定义该算法的某些特定步骤.

**实现**: 在其他编程语言中, 模板方法模式的实现方式一般是定义一个基类, 并要求子类完善算法, 为缺失的步骤提供步骤. 实现此模式的第一步是将通用的固定的步骤归纳到一个类中, 而允许改变的步骤则需要定义成可通过属性配置的函数. 

**使用场景**: 此模式可以选择性的允许外界在不修改原有类的情况下, 修改任意算法中的某些步骤的具体实现. **钩子方法的引入使得子类方法可以控制父类的行为.** 

## 4.11 访问者模式
**访问者模式:** 提供一个作用于某对象结构中各元素的操作表示, 它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作. 访问者模式是一种对象行为型模式.

![](images/1333713874_7112.gif)

访问者模式中, 对象结构存储了不同类型的元素对象, 以提供不同访问者访问. 访问者包含两个层次, 一个是访问者层次结构, 提供了抽象访问和具体访问者, 一个是元素层次结构, 提供了抽象元素和具体元素. 相同的访问者可以以不同的方式访问不同元素, 相同元素可以接受不同的访问者以不同访问方式访问. 在访问者模式中, 增加新的访问者无序修改原有系统, 系统具有较好的可扩展性. 

在访问者模式中，抽象访问者定义了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法，而具体访问者可以实现这些访问方法。这些访问方法的命名一般有两种方式：一种是直接在方法名中标明待访问元素对象的具体类型，如visitElementA(ElementA elementA)，还有一种是统一取名为visit()，通过参数类型的不同来定义一系列重载的visit()方法。

**优点**

1. 增加新的访问操作很方便. 使用访问者模式, 增加新的访问操作意味着增加一个新的具体访问者类, 实现简单, 无需修改源代码, 符合开闭原则.
2. 将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。
3. 让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。

# 5.其它