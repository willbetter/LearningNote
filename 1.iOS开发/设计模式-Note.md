**重点:** 六大设计原则, 
# 1.设计原则

* **单一职责原则**. 一个类只负责一件事.
* **开闭原则**. 对修改关闭, 对扩展开放.
* **接口隔离原则**. 使用多个专门的协议, 而不是一个庞大臃肿的协议; 协议中方法尽量精简. 例如,UITableViewDelegate,UITableViewDataSource使用两个协议而不是一个协议, 这样更符合接口隔离原则.
* **依赖倒置原则**. 抽象不不应该依赖具体实现, 具体实现可以依赖于抽象.
* **里氏替换原则**. 父类可以被之类无缝替换, 且原有功能不受影响. (KVO遵从了这个法则,无缝使用子类)
* **迪米特法则**. 一个对象应当对其它对象尽可能少的了解. 高内聚,低耦合.

# 2.六个创建型模式
## 2.1 简单工厂模式
## 2.2 工厂方法模式
## 2.3 抽象工厂模式
## 2.4 单例模式
## 2.5 原型模式
## 2.6 建造者模式

# 3.七个结构型模式
## 3.1 适配器模式
> **例子:** 笔记本电脑工作电压是20V, 我国家庭用电电压是220V, 他们之间无法直接连接, 这时候就需要一个适配器来适配两者的工作, 这就引入了电源适配器. 

![](images/1362066387_9870.jpg)

**适配器模式**: 将一个接口转换成客户希望的另一个接口, 使接口不兼容的哪些类型可以一起工作, 其别名为包装类. 适配器模式既可以作为类结构型模式, 也可以作为对象结构型模式. 

**在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。**
### 3.1.1 对象适配器
**对象适配器模式类图:**

![](iamges/1362066399_9469.jpg)

Adapter继承自目标抽象类, 实现request方法. Adapter引用了Adaptee, 在其request中调用需要适配的方法.

### 3.1.2 类适配器
类适配器模式和对象适配器模式最大的不同时适配器与适配者的关系不同, 对象适配器模式中适配器与适配者是关联关系; 类适配器中适配器与适配者是继承关系, 类适配器类图如下所示:

![](images/1362099343_7447.jpg)

Adapter继承自Adaptee, 实现了目标协议的request协议方法, 在方法内部调用适配者相关的方法, 完成适配工作.

### 3.1.3 小结
**优点:** 

1. 将目标类和适配者类解耦, 通过引入一个适配者类来重用现有的适配者类, 无需修改原有结构.
2. 增加类的透明性和复用性. 将具体的业务封装在适配者类中, 对客户端而言是透明的, 提高了适配者的复用性.

**使用场景:**

1. 系统需要使用一些现有的类, 而这些类的接口(方法名)不符合系统的需要, 甚至没有这些类的源代码.
2. 向创建一个可以重复使用的类, 用于与一些彼此没有太大关联的类, 包括一些可能将来需要引进的类一起工作.的.

## 3.2 桥接模式
> 示例: 设计一款跨平台的图片解压程序. 不同的图片格式是一个变化的纬度, 不同的操作系统平台又是一个变化的纬度. 这时候我们需要使用桥接模式, 将两者的变化连接起来.

![](images/1334506504_5936.gif)

**桥接模式:** 将抽象部分和它的实现部分分离, 使他们可以独立的变化. 它是一种对象结构型模式, 又称为柄体模式或者接口模式.

**桥接模式用于软件系统中某个类存在两个独立变化的纬度, 通过该模式将两个或者多个纬度的变化分离开来, 使两者可以独立扩展**, 让系统更加符合"单一职责原则". 它将两个独立变化的纬度设计为两个独立的继承等级结构, 并且在抽象层简历抽象关联, 该关联关系类似一条链接两个独立继承结构的桥, 故称桥接模式.

**桥接模式类图:**

![](images/1334505919_5277.gif)

**桥接模式和适配器模式配合使用**, 示例类图如下所示:

![](images/1334507018_4999.gif)

读取excel报表的程序需要使用ExcelAPI, 这时候通过一个适配器关联读取API类的对象, 在响应的方法中调用读取方法.

**小结**

优点: 

1. 分离抽象接口和实现部分. 桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。
2. 取代多重继承方案.
3. 提高系统扩展性, 在两个变化纬度中任意扩展一个纬度, 都不需要修改原有系统, 符合"开闭原则".

## 3.3 组合模式
## 3.4 装饰模式
## 3.5 外观模式
## 3.6 享元模式
## 3.7 代理模式

# 4.十一个行为型模式
## 4.1 责任链模式
**责任链模式:** 避免请求发送者和请求接收者耦合在一起, 让多个对象都有可能接收请求, 将这些对象链接成一条链, 并且沿着这条链传递请求, 直到有对象处理它为止. 责任链模式是一种对象行为型模式.

![](images/1333307613_2407.gif)

具体的处理者是抽象处理者的子类, 它有两大作用: 处理请求或者转发请求:

```
class ConcreteHandler extends Handler {
	public void handleRequest(String request) {
		if (请求满足条件) {
			//处理请求
		}
		else {
			this.successor.handleRequest(request);  //转发请求
		}
	}
}
```

责任链模式的关键在于对调用组件隐藏了责任链上单个链的实现细节. 责任链的创建可以放在客户端, 也可以放在责任链的基类中, 根据枚举类型创建不同的责任链.(放在客户端创建责任链可能更好一点, 更加符合开闭原则)

**应用:**

1. Cocoa框架中使用责任链来处理用户界面事件. 所有UI组件都派生自UIResponder类. 每个UI组件都是责任链中的链, 他们的位置反应的是其在界面组件层级关系中的位置, 层级顶端是责任链中的最后一个链.
2. 车主邦App中, Bundle图片获取器通过责任链模式实现. 如果是二倍屏, 则先获取二倍图, 没有的话获取三倍图, 一倍图. 
3. 消息处理也可以作为责任链来开发. 当收到一个消息, 把消息传递给第一个处理器, 如果不能处理则传递给第二个处理器...

**使用场景:** 当多个对象可以响应一个请求, 而最终只有一个对象会处理请求时, 可以使用此设计模式.

## 4.2 命令模式
## 4.3 解释器模式
## 4.4 迭代器模式
## 4.5 中介者模式
## 4.6 备忘录模式
## 4.7 观察者模式
## 4.8 状态模式
## 4.9 策略模式
## 4.10 模板方法模式
**模板方法模式**: 定义一个操作中算法的框架, 而将一些步骤延迟到子类中. 模板方法模式可以使得子类可以不改变一个算法结构即可重定义该算法的某些特定步骤.

**实现**: 在其他编程语言中, 模板方法模式的实现方式一般是定义一个基类, 并要求子类完善算法, 为缺失的步骤提供步骤. 实现此模式的第一步是将通用的固定的步骤归纳到一个类中, 而允许改变的步骤则需要定义成可通过属性配置的函数. 

**使用场景**: 此模式可以选择性的允许外界在不修改原有类的情况下, 修改任意算法中的某些步骤的具体实现. **钩子方法的引入使得子类方法可以控制父类的行为.** 

## 4.11 访问者模式

# 5.其它





桥接模式, 适配器模式, 单例模式, 命令模式